<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8"/>
    <title>Test Report</title>
    <link href="assets/style.css" rel="stylesheet" type="text/css"/></head>
  <body onLoad="init()">
    <script>/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this file,
 * You can obtain one at http://mozilla.org/MPL/2.0/. */


function toArray(iter) {
    if (iter === null) {
        return null;
    }
    return Array.prototype.slice.call(iter);
}

function find(selector, elem) {
    if (!elem) {
        elem = document;
    }
    return elem.querySelector(selector);
}

function find_all(selector, elem) {
    if (!elem) {
        elem = document;
    }
    return toArray(elem.querySelectorAll(selector));
}

function sort_column(elem) {
    toggle_sort_states(elem);
    var colIndex = toArray(elem.parentNode.childNodes).indexOf(elem);
    var key;
    if (elem.classList.contains('numeric')) {
        key = key_num;
    } else if (elem.classList.contains('result')) {
        key = key_result;
    } else {
        key = key_alpha;
    }
    sort_table(elem, key(colIndex));
}

function show_all_extras() {
    find_all('.col-result').forEach(show_extras);
}

function hide_all_extras() {
    find_all('.col-result').forEach(hide_extras);
}

function show_extras(colresult_elem) {
    var extras = colresult_elem.parentNode.nextElementSibling;
    var expandcollapse = colresult_elem.firstElementChild;
    extras.classList.remove("collapsed");
    expandcollapse.classList.remove("expander");
    expandcollapse.classList.add("collapser");
}

function hide_extras(colresult_elem) {
    var extras = colresult_elem.parentNode.nextElementSibling;
    var expandcollapse = colresult_elem.firstElementChild;
    extras.classList.add("collapsed");
    expandcollapse.classList.remove("collapser");
    expandcollapse.classList.add("expander");
}

function show_filters() {
    var filter_items = document.getElementsByClassName('filter');
    for (var i = 0; i < filter_items.length; i++)
        filter_items[i].hidden = false;
}

function add_collapse() {
    // Add links for show/hide all
    var resulttable = find('table#results-table');
    var showhideall = document.createElement("p");
    showhideall.innerHTML = '<a href="javascript:show_all_extras()">Show all details</a> / ' +
                            '<a href="javascript:hide_all_extras()">Hide all details</a>';
    resulttable.parentElement.insertBefore(showhideall, resulttable);

    // Add show/hide link to each result
    find_all('.col-result').forEach(function(elem) {
        var collapsed = get_query_parameter('collapsed') || 'Passed';
        var extras = elem.parentNode.nextElementSibling;
        var expandcollapse = document.createElement("span");
        if (collapsed.includes(elem.innerHTML)) {
            extras.classList.add("collapsed");
            expandcollapse.classList.add("expander");
        } else {
            expandcollapse.classList.add("collapser");
        }
        elem.appendChild(expandcollapse);

        elem.addEventListener("click", function(event) {
            if (event.currentTarget.parentNode.nextElementSibling.classList.contains("collapsed")) {
                show_extras(event.currentTarget);
            } else {
                hide_extras(event.currentTarget);
            }
        });
    })
}

function get_query_parameter(name) {
    var match = RegExp('[?&]' + name + '=([^&]*)').exec(window.location.search);
    return match && decodeURIComponent(match[1].replace(/\+/g, ' '));
}

function init () {
    reset_sort_headers();

    add_collapse();

    show_filters();

    toggle_sort_states(find('.initial-sort'));

    find_all('.sortable').forEach(function(elem) {
        elem.addEventListener("click",
                              function(event) {
                                  sort_column(elem);
                              }, false)
    });

};

function sort_table(clicked, key_func) {
    var rows = find_all('.results-table-row');
    var reversed = !clicked.classList.contains('asc');
    var sorted_rows = sort(rows, key_func, reversed);
    /* Whole table is removed here because browsers acts much slower
     * when appending existing elements.
     */
    var thead = document.getElementById("results-table-head");
    document.getElementById('results-table').remove();
    var parent = document.createElement("table");
    parent.id = "results-table";
    parent.appendChild(thead);
    sorted_rows.forEach(function(elem) {
        parent.appendChild(elem);
    });
    document.getElementsByTagName("BODY")[0].appendChild(parent);
}

function sort(items, key_func, reversed) {
    var sort_array = items.map(function(item, i) {
        return [key_func(item), i];
    });
    var multiplier = reversed ? -1 : 1;

    sort_array.sort(function(a, b) {
        var key_a = a[0];
        var key_b = b[0];
        return multiplier * (key_a >= key_b ? 1 : -1);
    });

    return sort_array.map(function(item) {
        var index = item[1];
        return items[index];
    });
}

function key_alpha(col_index) {
    return function(elem) {
        return elem.childNodes[1].childNodes[col_index].firstChild.data.toLowerCase();
    };
}

function key_num(col_index) {
    return function(elem) {
        return parseFloat(elem.childNodes[1].childNodes[col_index].firstChild.data);
    };
}

function key_result(col_index) {
    return function(elem) {
        var strings = ['Error', 'Failed', 'Rerun', 'XFailed', 'XPassed',
                       'Skipped', 'Passed'];
        return strings.indexOf(elem.childNodes[1].childNodes[col_index].firstChild.data);
    };
}

function reset_sort_headers() {
    find_all('.sort-icon').forEach(function(elem) {
        elem.parentNode.removeChild(elem);
    });
    find_all('.sortable').forEach(function(elem) {
        var icon = document.createElement("div");
        icon.className = "sort-icon";
        icon.textContent = "vvv";
        elem.insertBefore(icon, elem.firstChild);
        elem.classList.remove("desc", "active");
        elem.classList.add("asc", "inactive");
    });
}

function toggle_sort_states(elem) {
    //if active, toggle between asc and desc
    if (elem.classList.contains('active')) {
        elem.classList.toggle('asc');
        elem.classList.toggle('desc');
    }

    //if inactive, reset all other functions and add ascending active
    if (elem.classList.contains('inactive')) {
        reset_sort_headers();
        elem.classList.remove('inactive');
        elem.classList.add('active');
    }
}

function is_all_rows_hidden(value) {
  return value.hidden == false;
}

function filter_table(elem) {
    var outcome_att = "data-test-result";
    var outcome = elem.getAttribute(outcome_att);
    class_outcome = outcome + " results-table-row";
    var outcome_rows = document.getElementsByClassName(class_outcome);

    for(var i = 0; i < outcome_rows.length; i++){
        outcome_rows[i].hidden = !elem.checked;
    }

    var rows = find_all('.results-table-row').filter(is_all_rows_hidden);
    var all_rows_hidden = rows.length == 0 ? true : false;
    var not_found_message = document.getElementById("not-found-message");
    not_found_message.hidden = !all_rows_hidden;
}
</script>
    <h1>report.html</h1>
    <p>Report generated on 05-Dec-2018 at 17:23:24 by<a href="https://pypi.python.org/pypi/pytest-html"> pytest-html</a> v1.19.0</p>
    <h2>Environment</h2>
    <table id="environment">
      <tr>
        <td>Packages</td>
        <td>{&apos;py&apos;: &apos;1.7.0&apos;, &apos;pytest&apos;: &apos;4.0.1&apos;, &apos;pluggy&apos;: &apos;0.8.0&apos;}</td></tr>
      <tr>
        <td>Platform</td>
        <td>Darwin-18.2.0-x86_64-i386-64bit</td></tr>
      <tr>
        <td>Plugins</td>
        <td>{&apos;tavern&apos;: &apos;0.20.0&apos;, &apos;html&apos;: &apos;1.19.0&apos;, &apos;metadata&apos;: &apos;1.7.0&apos;}</td></tr>
      <tr>
        <td>Python</td>
        <td>2.7.10</td></tr></table>
    <h2>Summary</h2>
    <p>15 tests ran in 2.57 seconds. </p>
    <p class="filter" hidden="true">(Un)check the boxes to filter the results.</p><input checked="true" class="filter" data-test-result="passed" hidden="true" name="filter_checkbox" onChange="filter_table(this)" type="checkbox"/><span class="passed">9 passed</span>, <input checked="true" class="filter" data-test-result="skipped" disabled="true" hidden="true" name="filter_checkbox" onChange="filter_table(this)" type="checkbox"/><span class="skipped">0 skipped</span>, <input checked="true" class="filter" data-test-result="failed" hidden="true" name="filter_checkbox" onChange="filter_table(this)" type="checkbox"/><span class="failed">6 failed</span>, <input checked="true" class="filter" data-test-result="error" disabled="true" hidden="true" name="filter_checkbox" onChange="filter_table(this)" type="checkbox"/><span class="error">0 errors</span>, <input checked="true" class="filter" data-test-result="xfailed" disabled="true" hidden="true" name="filter_checkbox" onChange="filter_table(this)" type="checkbox"/><span class="xfailed">0 expected failures</span>, <input checked="true" class="filter" data-test-result="xpassed" disabled="true" hidden="true" name="filter_checkbox" onChange="filter_table(this)" type="checkbox"/><span class="xpassed">0 unexpected passes</span>
    <h2>Results</h2>
    <table id="results-table">
      <thead id="results-table-head">
        <tr>
          <th class="sortable result initial-sort" col="result">Result</th>
          <th class="sortable" col="name">Test</th>
          <th class="sortable numeric" col="duration">Duration</th>
          <th>Links</th></tr>
        <tr hidden="true" id="not-found-message">
          <th colspan="4">No results found. Try to check the filters</th></tr></thead>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">http/test_addTx.tavern.yaml::This method submits a transaction to the node.</td>
          <td class="col-duration">0.10</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;CallInfo when='call' exception: Test 'Both CurrentBlockHeight and HeaderHash ...te tx ===&gt; gas price is nil', actual["error"]["message"] = 'gas price is nil')&gt;<br/>func = &lt;function &lt;lambda&gt; at 0x10c365b90&gt;, when = 'call', treat_keyboard_interrupt_as_exception = False<br/><br/>    def __init__(self, func, when, treat_keyboard_interrupt_as_exception=False):<br/>        #: context of invocation: one of "setup", "call",<br/>        #: "teardown", "memocollect"<br/>        self.when = when<br/>        self.start = time()<br/>        try:<br/>&gt;           self.result = func()<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/_pytest/runner.py:211: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>&gt;       lambda: ihook(item=item, **kwds),<br/>        when=when,<br/>        treat_keyboard_interrupt_as_exception=item.config.getvalue("usepdb"),<br/>    )<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/_pytest/runner.py:193: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;_HookCaller 'pytest_runtest_call'&gt;, args = (), kwargs = {'item': &lt;YamlItem 'This method submits a transaction to the node.'&gt;}, notincall = set([])<br/><br/>    def __call__(self, *args, **kwargs):<br/>        if args:<br/>            raise TypeError("hook calling supports only keyword arguments")<br/>        assert not self.is_historic()<br/>        if self.spec and self.spec.argnames:<br/>            notincall = (<br/>                set(self.spec.argnames) - set(["__multicall__"]) - set(kwargs.keys())<br/>            )<br/>            if notincall:<br/>                warnings.warn(<br/>                    "Argument(s) {} which are declared in the hookspec "<br/>                    "can not be found in this hook call".format(tuple(notincall)),<br/>                    stacklevel=2,<br/>                )<br/>&gt;       return self._hookexec(self, self.get_hookimpls(), kwargs)<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/pluggy/hooks.py:284: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;_pytest.config.PytestPluginManager object at 0x10b920590&gt;, hook = &lt;_HookCaller 'pytest_runtest_call'&gt;<br/>methods = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/Users/frank/venv/testEnv/lib/python2.7/site-pa...t 0x10bee0c10&gt;&gt;, &lt;HookImpl plugin_name='logging-plugin', plugin=&lt;_pytest.logging.LoggingPlugin object at 0x10bf06f50&gt;&gt;]<br/>kwargs = {'item': &lt;YamlItem 'This method submits a transaction to the node.'&gt;}<br/><br/>    def _hookexec(self, hook, methods, kwargs):<br/>        # called from all hookcaller instances.<br/>        # enable_tracing will set its own wrapping function at self._inner_hookexec<br/>&gt;       return self._inner_hookexec(hook, methods, kwargs)<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/pluggy/manager.py:67: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>hook = &lt;_HookCaller 'pytest_runtest_call'&gt;<br/>methods = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/Users/frank/venv/testEnv/lib/python2.7/site-pa...t 0x10bee0c10&gt;&gt;, &lt;HookImpl plugin_name='logging-plugin', plugin=&lt;_pytest.logging.LoggingPlugin object at 0x10bf06f50&gt;&gt;]<br/>kwargs = {'item': &lt;YamlItem 'This method submits a transaction to the node.'&gt;}<br/><br/>    self._inner_hookexec = lambda hook, methods, kwargs: hook.multicall(<br/>        methods,<br/>        kwargs,<br/>&gt;       firstresult=hook.spec.opts.get("firstresult") if hook.spec else False,<br/>    )<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/pluggy/manager.py:61: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>hook_impls = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/Users/frank/venv/testEnv/lib/python2.7/site-pa...t 0x10bee0c10&gt;&gt;, &lt;HookImpl plugin_name='logging-plugin', plugin=&lt;_pytest.logging.LoggingPlugin object at 0x10bf06f50&gt;&gt;]<br/>caller_kwargs = {'item': &lt;YamlItem 'This method submits a transaction to the node.'&gt;}, firstresult = False<br/><br/>    def _multicall(hook_impls, caller_kwargs, firstresult=False):<br/>        """Execute a call into multiple python functions/methods and return the<br/>        result(s).<br/>    <br/>        ``caller_kwargs`` comes from _HookCaller.__call__().<br/>        """<br/>        __tracebackhide__ = True<br/>        results = []<br/>        excinfo = None<br/>        try:  # run impl and wrapper setup functions in a loop<br/>            teardowns = []<br/>            try:<br/>                for hook_impl in reversed(hook_impls):<br/>                    try:<br/>                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]<br/>                    except KeyError:<br/>                        for argname in hook_impl.argnames:<br/>                            if argname not in caller_kwargs:<br/>                                raise HookCallError(<br/>                                    "hook call must provide argument %r" % (argname,)<br/>                                )<br/>    <br/>                    if hook_impl.hookwrapper:<br/>                        try:<br/>                            gen = hook_impl.function(*args)<br/>                            next(gen)  # first yield<br/>                            teardowns.append(gen)<br/>                        except StopIteration:<br/>                            _raise_wrapfail(gen, "did not yield")<br/>                    else:<br/>                        res = hook_impl.function(*args)<br/>                        if res is not None:<br/>                            results.append(res)<br/>                            if firstresult:  # halt further impl calls<br/>                                break<br/>            except BaseException:<br/>                excinfo = sys.exc_info()<br/>        finally:<br/>            if firstresult:  # first result hooks return a single value<br/>                outcome = _Result(results[0] if results else None, excinfo)<br/>            else:<br/>                outcome = _Result(results, excinfo)<br/>    <br/>            # run all wrapper post-yield blocks<br/>            for gen in reversed(teardowns):<br/>                try:<br/>                    gen.send(outcome)<br/>                    _raise_wrapfail(gen, "has second yield")<br/>                except StopIteration:<br/>                    pass<br/>    <br/>&gt;           return outcome.get_result()<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/pluggy/callers.py:208: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;pluggy.callers._Result object at 0x10c385d10&gt;<br/><br/>    def get_result(self):<br/>        """Get the result(s) for this hook call.<br/>    <br/>        If the hook was marked as a ``firstresult`` only a single value<br/>        will be returned otherwise a list of results.<br/>        """<br/>        __tracebackhide__ = True<br/>        if self._excinfo is None:<br/>            return self._result<br/>        else:<br/>            ex = self._excinfo<br/>            if _py3:<br/>                raise ex[1].with_traceback(ex[2])<br/>&gt;           _reraise(*ex)  # noqa<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/pluggy/callers.py:81: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>hook_impls = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/Users/frank/venv/testEnv/lib/python2.7/site-pa...t 0x10bee0c10&gt;&gt;, &lt;HookImpl plugin_name='logging-plugin', plugin=&lt;_pytest.logging.LoggingPlugin object at 0x10bf06f50&gt;&gt;]<br/>caller_kwargs = {'item': &lt;YamlItem 'This method submits a transaction to the node.'&gt;}, firstresult = False<br/><br/>    def _multicall(hook_impls, caller_kwargs, firstresult=False):<br/>        """Execute a call into multiple python functions/methods and return the<br/>        result(s).<br/>    <br/>        ``caller_kwargs`` comes from _HookCaller.__call__().<br/>        """<br/>        __tracebackhide__ = True<br/>        results = []<br/>        excinfo = None<br/>        try:  # run impl and wrapper setup functions in a loop<br/>            teardowns = []<br/>            try:<br/>                for hook_impl in reversed(hook_impls):<br/>                    try:<br/>                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]<br/>                    except KeyError:<br/>                        for argname in hook_impl.argnames:<br/>                            if argname not in caller_kwargs:<br/>                                raise HookCallError(<br/>                                    "hook call must provide argument %r" % (argname,)<br/>                                )<br/>    <br/>                    if hook_impl.hookwrapper:<br/>                        try:<br/>                            gen = hook_impl.function(*args)<br/>                            next(gen)  # first yield<br/>                            teardowns.append(gen)<br/>                        except StopIteration:<br/>                            _raise_wrapfail(gen, "did not yield")<br/>                    else:<br/>&gt;                       res = hook_impl.function(*args)<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/pluggy/callers.py:187: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>item = &lt;YamlItem 'This method submits a transaction to the node.'&gt;<br/><br/>    def pytest_runtest_call(item):<br/>        _update_current_test_var(item, "call")<br/>        sys.last_type, sys.last_value, sys.last_traceback = (None, None, None)<br/>        try:<br/>&gt;           item.runtest()<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/_pytest/runner.py:121: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;YamlItem 'This method submits a transaction to the node.'&gt;<br/><br/>    def runtest(self):<br/>        self.global_cfg = self._parse_arguments()<br/>    <br/>        self.global_cfg.setdefault("variables", {})<br/>    <br/>        load_plugins(self.global_cfg)<br/>    <br/>        # INTERNAL<br/>        # NOTE - now that we can 'mark' tests, we could use pytest.mark.xfail<br/>        # instead. This doesn't differentiate between an error in verification<br/>        # and an error when running the test though.<br/>        xfail = self.spec.get("_xfail", False)<br/>    <br/>        try:<br/>            verify_tests(self.spec)<br/>    <br/>            fixture_values = self._load_fixture_values()<br/>            self.global_cfg["variables"].update(fixture_values)<br/>    <br/>&gt;           run_test(self.path, self.spec, self.global_cfg)<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/tavern/testutils/pytesthook.py:431: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>in_file = local('/Users/frank/code/github/api-test/http/test_addTx.tavern.yaml')<br/>test_spec = {'stages': [{'request': {'url': '{service.proto:s}://{service.host:s}:{service...local server'}], 'test_name': 'This method submits a transaction to the node.'}<br/>global_cfg = {'backends': {'http': 'requests', 'mqtt': 'paho-mqtt'}, 'strict': [], 'variables': {'node': {'Coinbase': '0xe2bbc9fadb...t-type': 'application/json'}, 'json..._TEXT_ENCODING': '0x1F7:0x0:0x0', 'PWD': '/Users/frank/code/github/api-test'}}&gt;}}<br/><br/>    def run_test(in_file, test_spec, global_cfg):<br/>        """Run a single tavern test<br/>    <br/>        Note that each tavern test can consist of multiple requests (log in,<br/>        create, update, delete, etc).<br/>    <br/>        The global configuration is copied and used as an initial configuration for<br/>        this test. Any values which are saved from any tests are saved into this<br/>        test block and can be used for formatting in later stages in the test.<br/>    <br/>        Args:<br/>            in_file (str): filename containing this test<br/>            test_spec (dict): The specification for this test<br/>            global_cfg (dict): Any global configuration for this test<br/>    <br/>        No Longer Raises:<br/>            TavernException: If any of the tests failed<br/>        """<br/>    <br/>        # pylint: disable=too-many-locals<br/>    <br/>        # Initialise test config for this test with the global configuration before<br/>        # starting<br/>        test_block_config = dict(global_cfg)<br/>    <br/>        if "variables" not in test_block_config:<br/>            test_block_config["variables"] = {}<br/>    <br/>        tavern_box = Box({<br/>            "env_vars": dict(os.environ),<br/>        })<br/>    <br/>        if not test_spec:<br/>            logger.warning("Empty test block in %s", in_file)<br/>            return<br/>    <br/>        available_stages = {}<br/>        if test_spec.get("includes"):<br/>            for included in test_spec["includes"]:<br/>                if "variables" in included:<br/>                    formatted_include = format_keys(included["variables"], {"tavern": tavern_box})<br/>                    test_block_config["variables"].update(formatted_include)<br/>    <br/>                if "stages" in included:<br/>                    for stage in included["stages"]:<br/>                        if stage["id"] in available_stages:<br/>                            raise exceptions.DuplicateStageDefinitionError(<br/>                                "Stage with specified id already defined: {}".format(stage["id"]))<br/>                        available_stages[stage["id"]] = stage<br/>    <br/>        test_block_config["variables"]["tavern"] = tavern_box<br/>    <br/>        test_block_name = test_spec["test_name"]<br/>    <br/>        # Strict on body by default<br/>        default_strictness = test_block_config["strict"]<br/>    <br/>        logger.info("Running test : %s", test_block_name)<br/>    <br/>        with ExitStack() as stack:<br/>            test_spec["stages"] = _resolve_test_stages(test_spec, available_stages)<br/>            sessions = get_extra_sessions(test_spec, test_block_config)<br/>    <br/>            for name, session in sessions.items():<br/>                logger.debug("Entering context for %s", name)<br/>                stack.enter_context(session)<br/>    <br/>            # Run tests in a path in order<br/>            for stage in test_spec["stages"]:<br/>                if stage.get('skip'):<br/>                    continue<br/>    <br/>                test_block_config["strict"] = default_strictness<br/>    <br/>                # Can be overridden per stage<br/>                # NOTE<br/>                # this is hardcoded to check for the 'response' block. In the far<br/>                # future there might not be a response block, but at the moment it<br/>                # is the hardcoded value for any HTTP request.<br/>                if stage.get("response", {}):<br/>                    if stage.get("response").get("strict", None) is not None:<br/>                        stage_strictness = stage.get("response").get("strict", None)<br/>                    elif test_spec.get("strict", None) is not None:<br/>                        stage_strictness = test_spec.get("strict", None)<br/>                    else:<br/>                        stage_strictness = default_strictness<br/>    <br/>                    logger.debug("Strict key checking for this stage is '%s'", stage_strictness)<br/>    <br/>                    test_block_config["strict"] = stage_strictness<br/>                elif default_strictness:<br/>                    logger.debug("Default strictness '%s' ignored for this stage", default_strictness)<br/>    <br/>                run_stage_ = run_stage<br/>                if stage.get('max_retries'):<br/>                    run_stage_ = retry(stage)(run_stage_)<br/>    <br/>                try:<br/>&gt;                   run_stage_(sessions, stage, tavern_box, test_block_config)<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/tavern/core.py:145: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>sessions = {'requests': &lt;requests.sessions.Session object at 0x10c134a50&gt;}<br/>stage = {'request': {'url': '{service.proto:s}://{service.host:s}:{service.port:d}', '...d to validate tx ===&gt; gas price is nil', 'code': -32000}}, 'status_code': 200}}<br/>tavern_box = &lt;Box: {'request_vars': {'headers': {'content-type': 'application/json'}, 'json..._TEXT_ENCODING': '0x1F7:0x0:0x0', 'PWD': '/Users/frank/code/github/api-test'}}&gt;<br/>test_block_config = {'backends': {'http': 'requests', 'mqtt': 'paho-mqtt'}, 'strict': [], 'variables': {'node': {'Coinbase': '0xe2bbc9fadb...t-type': 'application/json'}, 'json..._TEXT_ENCODING': '0x1F7:0x0:0x0', 'PWD': '/Users/frank/code/github/api-test'}}&gt;}}<br/><br/>    def run_stage(sessions, stage, tavern_box, test_block_config):<br/>        """Run one stage from the test<br/>    <br/>        Args:<br/>            sessions (list): List of relevant 'session' objects used for this test<br/>            stage (dict): specification of stage to be run<br/>            tavern_box (box.Box): Box object containing format variables to be used<br/>                in test<br/>            test_block_config (dict): available variables for test<br/>        """<br/>        name = stage["name"]<br/>    <br/>        r = get_request_type(stage, test_block_config, sessions)<br/>    <br/>        tavern_box.update(request_vars=r.request_vars)<br/>    <br/>        expected = get_expected(stage, test_block_config, sessions)<br/>    <br/>        delay(stage, "before")<br/>    <br/>        logger.info("Running stage : %s", name)<br/>        response = r.run()<br/>    <br/>        verifiers = get_verifiers(stage, test_block_config, sessions, expected)<br/>        for v in verifiers:<br/>&gt;           saved = v.verify(response)<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/tavern/core.py:180: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;tavern._plugins.rest.response.RestResponse object at 0x10c308610&gt;, response = &lt;Response [200]&gt;<br/><br/>    def verify(self, response):<br/>        """Verify response against expected values and returns any values that<br/>        we wanted to save for use in future requests<br/>    <br/>        There are various ways to 'validate' a block - a specific function, just<br/>        matching values, validating a schema, etc...<br/>    <br/>        Args:<br/>            response (requests.Response): response object<br/>    <br/>        Returns:<br/>            dict: Any saved values<br/>    <br/>        Raises:<br/>            TestFailError: Something went wrong with validating the response<br/>        """<br/>        # pylint: disable=too-many-statements<br/>    <br/>        self._verbose_log_response(response)<br/>    <br/>        self.response = response<br/>        self.status_code = response.status_code<br/>    <br/>        try:<br/>            body = response.json()<br/>        except ValueError:<br/>            body = None<br/>    <br/>        self._check_status_code(response.status_code, body)<br/>    <br/>        if self.validate_function:<br/>            try:<br/>                self.validate_function(response)<br/>            except Exception as e: #pylint: disable=broad-except<br/>                self._adderr("Error calling validate function '%s':\n%s",<br/>                    self.validate_function.func,<br/>                    indent_err_text(traceback.format_exc()),<br/>                    e=e)<br/>    <br/>        # Get any keys to save<br/>        saved = {}<br/>    <br/>        redirect_query_params = self._get_redirect_query_params(response)<br/>    <br/>        saved.update(self._save_value("body", body))<br/>        saved.update(self._save_value("headers", response.headers))<br/>        saved.update(self._save_value("redirect_query_params", redirect_query_params))<br/>    <br/>        for cookie in self.expected.get("cookies", []):<br/>            if cookie not in response.cookies:<br/>                self._adderr("No cookie named '%s' in response", cookie)<br/>    <br/>        try:<br/>            wrapped = get_wrapped_response_function(self.expected["save"]["$ext"])<br/>        except KeyError:<br/>            logger.debug("No save function for this stage")<br/>        else:<br/>            try:<br/>                to_save = wrapped(response)<br/>            except Exception as e: #pylint: disable=broad-except<br/>                self._adderr("Error calling save function '%s':\n%s",<br/>                    wrapped.func,<br/>                    indent_err_text(traceback.format_exc()),<br/>                    e=e)<br/>            else:<br/>                if isinstance(to_save, dict):<br/>                    saved.update(to_save)<br/>                elif to_save is not None:<br/>                    self._adderr("Unexpected return value '%s' from $ext save function")<br/>    <br/>        self._validate_block("body", body)<br/>        self._validate_block("headers", response.headers)<br/>        self._validate_block("redirect_query_params", redirect_query_params)<br/>    <br/>        if self.errors:<br/>&gt;           raise TestFailError("Test '{:s}' failed:\n{:s}".format(self.name, self._str_errors()), failures=self.errors)<br/><span class="error">E           TestFailError: Test 'Both CurrentBlockHeight and HeaderHash are changing frequently.' failed:</span><br/><span class="error">E           - Value mismatch in body: Key mismatch: (expected["error"]["message"] = 'failed to validate object ===&gt; failed to validate tx ===&gt; gas price is nil', actual["error"]["message"] = 'gas price is nil')</span><br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/tavern/_plugins/rest/response.py:207: TestFailError<br/>------------------------------ Captured log call -------------------------------<br/>base.py                     37 ERROR    Value mismatch in body: Key mismatch: (expected["error"]["message"] = 'failed to validate object ===&gt; failed to validate tx ===&gt; gas price is nil', actual["error"]["message"] = 'gas price is nil')</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">http/test_getBlock.tavern.yaml::This method is used to obtain the block content based on block height or block hash.</td>
          <td class="col-duration">0.10</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;CallInfo when='call' exception: Test 'Both CurrentBlockHeight and HeaderHash ...Hash"] = '0x0a8ec89d8a6dfed0681157c3a2ef3547df99b28933b4450d3b0b423f47478bad')&gt;<br/>func = &lt;function &lt;lambda&gt; at 0x10c365f50&gt;, when = 'call', treat_keyboard_interrupt_as_exception = False<br/><br/>    def __init__(self, func, when, treat_keyboard_interrupt_as_exception=False):<br/>        #: context of invocation: one of "setup", "call",<br/>        #: "teardown", "memocollect"<br/>        self.when = when<br/>        self.start = time()<br/>        try:<br/>&gt;           self.result = func()<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/_pytest/runner.py:211: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>&gt;       lambda: ihook(item=item, **kwds),<br/>        when=when,<br/>        treat_keyboard_interrupt_as_exception=item.config.getvalue("usepdb"),<br/>    )<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/_pytest/runner.py:193: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;_HookCaller 'pytest_runtest_call'&gt;, args = (), kwargs = {'item': &lt;YamlItem 'This method is used to obtain the block content based on block height or block hash.'&gt;}<br/>notincall = set([])<br/><br/>    def __call__(self, *args, **kwargs):<br/>        if args:<br/>            raise TypeError("hook calling supports only keyword arguments")<br/>        assert not self.is_historic()<br/>        if self.spec and self.spec.argnames:<br/>            notincall = (<br/>                set(self.spec.argnames) - set(["__multicall__"]) - set(kwargs.keys())<br/>            )<br/>            if notincall:<br/>                warnings.warn(<br/>                    "Argument(s) {} which are declared in the hookspec "<br/>                    "can not be found in this hook call".format(tuple(notincall)),<br/>                    stacklevel=2,<br/>                )<br/>&gt;       return self._hookexec(self, self.get_hookimpls(), kwargs)<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/pluggy/hooks.py:284: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;_pytest.config.PytestPluginManager object at 0x10b920590&gt;, hook = &lt;_HookCaller 'pytest_runtest_call'&gt;<br/>methods = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/Users/frank/venv/testEnv/lib/python2.7/site-pa...t 0x10bee0c10&gt;&gt;, &lt;HookImpl plugin_name='logging-plugin', plugin=&lt;_pytest.logging.LoggingPlugin object at 0x10bf06f50&gt;&gt;]<br/>kwargs = {'item': &lt;YamlItem 'This method is used to obtain the block content based on block height or block hash.'&gt;}<br/><br/>    def _hookexec(self, hook, methods, kwargs):<br/>        # called from all hookcaller instances.<br/>        # enable_tracing will set its own wrapping function at self._inner_hookexec<br/>&gt;       return self._inner_hookexec(hook, methods, kwargs)<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/pluggy/manager.py:67: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>hook = &lt;_HookCaller 'pytest_runtest_call'&gt;<br/>methods = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/Users/frank/venv/testEnv/lib/python2.7/site-pa...t 0x10bee0c10&gt;&gt;, &lt;HookImpl plugin_name='logging-plugin', plugin=&lt;_pytest.logging.LoggingPlugin object at 0x10bf06f50&gt;&gt;]<br/>kwargs = {'item': &lt;YamlItem 'This method is used to obtain the block content based on block height or block hash.'&gt;}<br/><br/>    self._inner_hookexec = lambda hook, methods, kwargs: hook.multicall(<br/>        methods,<br/>        kwargs,<br/>&gt;       firstresult=hook.spec.opts.get("firstresult") if hook.spec else False,<br/>    )<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/pluggy/manager.py:61: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>hook_impls = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/Users/frank/venv/testEnv/lib/python2.7/site-pa...t 0x10bee0c10&gt;&gt;, &lt;HookImpl plugin_name='logging-plugin', plugin=&lt;_pytest.logging.LoggingPlugin object at 0x10bf06f50&gt;&gt;]<br/>caller_kwargs = {'item': &lt;YamlItem 'This method is used to obtain the block content based on block height or block hash.'&gt;}, firstresult = False<br/><br/>    def _multicall(hook_impls, caller_kwargs, firstresult=False):<br/>        """Execute a call into multiple python functions/methods and return the<br/>        result(s).<br/>    <br/>        ``caller_kwargs`` comes from _HookCaller.__call__().<br/>        """<br/>        __tracebackhide__ = True<br/>        results = []<br/>        excinfo = None<br/>        try:  # run impl and wrapper setup functions in a loop<br/>            teardowns = []<br/>            try:<br/>                for hook_impl in reversed(hook_impls):<br/>                    try:<br/>                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]<br/>                    except KeyError:<br/>                        for argname in hook_impl.argnames:<br/>                            if argname not in caller_kwargs:<br/>                                raise HookCallError(<br/>                                    "hook call must provide argument %r" % (argname,)<br/>                                )<br/>    <br/>                    if hook_impl.hookwrapper:<br/>                        try:<br/>                            gen = hook_impl.function(*args)<br/>                            next(gen)  # first yield<br/>                            teardowns.append(gen)<br/>                        except StopIteration:<br/>                            _raise_wrapfail(gen, "did not yield")<br/>                    else:<br/>                        res = hook_impl.function(*args)<br/>                        if res is not None:<br/>                            results.append(res)<br/>                            if firstresult:  # halt further impl calls<br/>                                break<br/>            except BaseException:<br/>                excinfo = sys.exc_info()<br/>        finally:<br/>            if firstresult:  # first result hooks return a single value<br/>                outcome = _Result(results[0] if results else None, excinfo)<br/>            else:<br/>                outcome = _Result(results, excinfo)<br/>    <br/>            # run all wrapper post-yield blocks<br/>            for gen in reversed(teardowns):<br/>                try:<br/>                    gen.send(outcome)<br/>                    _raise_wrapfail(gen, "has second yield")<br/>                except StopIteration:<br/>                    pass<br/>    <br/>&gt;           return outcome.get_result()<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/pluggy/callers.py:208: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;pluggy.callers._Result object at 0x10cf00c50&gt;<br/><br/>    def get_result(self):<br/>        """Get the result(s) for this hook call.<br/>    <br/>        If the hook was marked as a ``firstresult`` only a single value<br/>        will be returned otherwise a list of results.<br/>        """<br/>        __tracebackhide__ = True<br/>        if self._excinfo is None:<br/>            return self._result<br/>        else:<br/>            ex = self._excinfo<br/>            if _py3:<br/>                raise ex[1].with_traceback(ex[2])<br/>&gt;           _reraise(*ex)  # noqa<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/pluggy/callers.py:81: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>hook_impls = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/Users/frank/venv/testEnv/lib/python2.7/site-pa...t 0x10bee0c10&gt;&gt;, &lt;HookImpl plugin_name='logging-plugin', plugin=&lt;_pytest.logging.LoggingPlugin object at 0x10bf06f50&gt;&gt;]<br/>caller_kwargs = {'item': &lt;YamlItem 'This method is used to obtain the block content based on block height or block hash.'&gt;}, firstresult = False<br/><br/>    def _multicall(hook_impls, caller_kwargs, firstresult=False):<br/>        """Execute a call into multiple python functions/methods and return the<br/>        result(s).<br/>    <br/>        ``caller_kwargs`` comes from _HookCaller.__call__().<br/>        """<br/>        __tracebackhide__ = True<br/>        results = []<br/>        excinfo = None<br/>        try:  # run impl and wrapper setup functions in a loop<br/>            teardowns = []<br/>            try:<br/>                for hook_impl in reversed(hook_impls):<br/>                    try:<br/>                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]<br/>                    except KeyError:<br/>                        for argname in hook_impl.argnames:<br/>                            if argname not in caller_kwargs:<br/>                                raise HookCallError(<br/>                                    "hook call must provide argument %r" % (argname,)<br/>                                )<br/>    <br/>                    if hook_impl.hookwrapper:<br/>                        try:<br/>                            gen = hook_impl.function(*args)<br/>                            next(gen)  # first yield<br/>                            teardowns.append(gen)<br/>                        except StopIteration:<br/>                            _raise_wrapfail(gen, "did not yield")<br/>                    else:<br/>&gt;                       res = hook_impl.function(*args)<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/pluggy/callers.py:187: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>item = &lt;YamlItem 'This method is used to obtain the block content based on block height or block hash.'&gt;<br/><br/>    def pytest_runtest_call(item):<br/>        _update_current_test_var(item, "call")<br/>        sys.last_type, sys.last_value, sys.last_traceback = (None, None, None)<br/>        try:<br/>&gt;           item.runtest()<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/_pytest/runner.py:121: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;YamlItem 'This method is used to obtain the block content based on block height or block hash.'&gt;<br/><br/>    def runtest(self):<br/>        self.global_cfg = self._parse_arguments()<br/>    <br/>        self.global_cfg.setdefault("variables", {})<br/>    <br/>        load_plugins(self.global_cfg)<br/>    <br/>        # INTERNAL<br/>        # NOTE - now that we can 'mark' tests, we could use pytest.mark.xfail<br/>        # instead. This doesn't differentiate between an error in verification<br/>        # and an error when running the test though.<br/>        xfail = self.spec.get("_xfail", False)<br/>    <br/>        try:<br/>            verify_tests(self.spec)<br/>    <br/>            fixture_values = self._load_fixture_values()<br/>            self.global_cfg["variables"].update(fixture_values)<br/>    <br/>&gt;           run_test(self.path, self.spec, self.global_cfg)<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/tavern/testutils/pytesthook.py:431: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>in_file = local('/Users/frank/code/github/api-test/http/test_getBlock.tavern.yaml')<br/>test_spec = {'stages': [{'request': {'url': '{service.proto:s}://{service.host:s}:{service...thod is used to obtain the block content based on block height or block hash.'}<br/>global_cfg = {'backends': {'http': 'requests', 'mqtt': 'paho-mqtt'}, 'strict': [], 'variables': {'node': {'Coinbase': '0xe2bbc9fadb...t-type': 'application/json'}, 'json..._TEXT_ENCODING': '0x1F7:0x0:0x0', 'PWD': '/Users/frank/code/github/api-test'}}&gt;}}<br/><br/>    def run_test(in_file, test_spec, global_cfg):<br/>        """Run a single tavern test<br/>    <br/>        Note that each tavern test can consist of multiple requests (log in,<br/>        create, update, delete, etc).<br/>    <br/>        The global configuration is copied and used as an initial configuration for<br/>        this test. Any values which are saved from any tests are saved into this<br/>        test block and can be used for formatting in later stages in the test.<br/>    <br/>        Args:<br/>            in_file (str): filename containing this test<br/>            test_spec (dict): The specification for this test<br/>            global_cfg (dict): Any global configuration for this test<br/>    <br/>        No Longer Raises:<br/>            TavernException: If any of the tests failed<br/>        """<br/>    <br/>        # pylint: disable=too-many-locals<br/>    <br/>        # Initialise test config for this test with the global configuration before<br/>        # starting<br/>        test_block_config = dict(global_cfg)<br/>    <br/>        if "variables" not in test_block_config:<br/>            test_block_config["variables"] = {}<br/>    <br/>        tavern_box = Box({<br/>            "env_vars": dict(os.environ),<br/>        })<br/>    <br/>        if not test_spec:<br/>            logger.warning("Empty test block in %s", in_file)<br/>            return<br/>    <br/>        available_stages = {}<br/>        if test_spec.get("includes"):<br/>            for included in test_spec["includes"]:<br/>                if "variables" in included:<br/>                    formatted_include = format_keys(included["variables"], {"tavern": tavern_box})<br/>                    test_block_config["variables"].update(formatted_include)<br/>    <br/>                if "stages" in included:<br/>                    for stage in included["stages"]:<br/>                        if stage["id"] in available_stages:<br/>                            raise exceptions.DuplicateStageDefinitionError(<br/>                                "Stage with specified id already defined: {}".format(stage["id"]))<br/>                        available_stages[stage["id"]] = stage<br/>    <br/>        test_block_config["variables"]["tavern"] = tavern_box<br/>    <br/>        test_block_name = test_spec["test_name"]<br/>    <br/>        # Strict on body by default<br/>        default_strictness = test_block_config["strict"]<br/>    <br/>        logger.info("Running test : %s", test_block_name)<br/>    <br/>        with ExitStack() as stack:<br/>            test_spec["stages"] = _resolve_test_stages(test_spec, available_stages)<br/>            sessions = get_extra_sessions(test_spec, test_block_config)<br/>    <br/>            for name, session in sessions.items():<br/>                logger.debug("Entering context for %s", name)<br/>                stack.enter_context(session)<br/>    <br/>            # Run tests in a path in order<br/>            for stage in test_spec["stages"]:<br/>                if stage.get('skip'):<br/>                    continue<br/>    <br/>                test_block_config["strict"] = default_strictness<br/>    <br/>                # Can be overridden per stage<br/>                # NOTE<br/>                # this is hardcoded to check for the 'response' block. In the far<br/>                # future there might not be a response block, but at the moment it<br/>                # is the hardcoded value for any HTTP request.<br/>                if stage.get("response", {}):<br/>                    if stage.get("response").get("strict", None) is not None:<br/>                        stage_strictness = stage.get("response").get("strict", None)<br/>                    elif test_spec.get("strict", None) is not None:<br/>                        stage_strictness = test_spec.get("strict", None)<br/>                    else:<br/>                        stage_strictness = default_strictness<br/>    <br/>                    logger.debug("Strict key checking for this stage is '%s'", stage_strictness)<br/>    <br/>                    test_block_config["strict"] = stage_strictness<br/>                elif default_strictness:<br/>                    logger.debug("Default strictness '%s' ignored for this stage", default_strictness)<br/>    <br/>                run_stage_ = run_stage<br/>                if stage.get('max_retries'):<br/>                    run_stage_ = retry(stage)(run_stage_)<br/>    <br/>                try:<br/>&gt;                   run_stage_(sessions, stage, tavern_box, test_block_config)<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/tavern/core.py:145: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>sessions = {'requests': &lt;requests.sessions.Session object at 0x10c13be50&gt;}<br/>stage = {'request': {'url': '{service.proto:s}://{service.host:s}:{service.port:d}', '...5ed3d36b7ae3e1d3f9a3a5191aaaf1db740afa68b4db2ff355bc79'}}, 'status_code': 200}}<br/>tavern_box = &lt;Box: {'request_vars': {'headers': {'content-type': 'application/json'}, 'json..._TEXT_ENCODING': '0x1F7:0x0:0x0', 'PWD': '/Users/frank/code/github/api-test'}}&gt;<br/>test_block_config = {'backends': {'http': 'requests', 'mqtt': 'paho-mqtt'}, 'strict': [], 'variables': {'node': {'Coinbase': '0xe2bbc9fadb...t-type': 'application/json'}, 'json..._TEXT_ENCODING': '0x1F7:0x0:0x0', 'PWD': '/Users/frank/code/github/api-test'}}&gt;}}<br/><br/>    def run_stage(sessions, stage, tavern_box, test_block_config):<br/>        """Run one stage from the test<br/>    <br/>        Args:<br/>            sessions (list): List of relevant 'session' objects used for this test<br/>            stage (dict): specification of stage to be run<br/>            tavern_box (box.Box): Box object containing format variables to be used<br/>                in test<br/>            test_block_config (dict): available variables for test<br/>        """<br/>        name = stage["name"]<br/>    <br/>        r = get_request_type(stage, test_block_config, sessions)<br/>    <br/>        tavern_box.update(request_vars=r.request_vars)<br/>    <br/>        expected = get_expected(stage, test_block_config, sessions)<br/>    <br/>        delay(stage, "before")<br/>    <br/>        logger.info("Running stage : %s", name)<br/>        response = r.run()<br/>    <br/>        verifiers = get_verifiers(stage, test_block_config, sessions, expected)<br/>        for v in verifiers:<br/>&gt;           saved = v.verify(response)<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/tavern/core.py:180: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;tavern._plugins.rest.response.RestResponse object at 0x10cf36810&gt;, response = &lt;Response [200]&gt;<br/><br/>    def verify(self, response):<br/>        """Verify response against expected values and returns any values that<br/>        we wanted to save for use in future requests<br/>    <br/>        There are various ways to 'validate' a block - a specific function, just<br/>        matching values, validating a schema, etc...<br/>    <br/>        Args:<br/>            response (requests.Response): response object<br/>    <br/>        Returns:<br/>            dict: Any saved values<br/>    <br/>        Raises:<br/>            TestFailError: Something went wrong with validating the response<br/>        """<br/>        # pylint: disable=too-many-statements<br/>    <br/>        self._verbose_log_response(response)<br/>    <br/>        self.response = response<br/>        self.status_code = response.status_code<br/>    <br/>        try:<br/>            body = response.json()<br/>        except ValueError:<br/>            body = None<br/>    <br/>        self._check_status_code(response.status_code, body)<br/>    <br/>        if self.validate_function:<br/>            try:<br/>                self.validate_function(response)<br/>            except Exception as e: #pylint: disable=broad-except<br/>                self._adderr("Error calling validate function '%s':\n%s",<br/>                    self.validate_function.func,<br/>                    indent_err_text(traceback.format_exc()),<br/>                    e=e)<br/>    <br/>        # Get any keys to save<br/>        saved = {}<br/>    <br/>        redirect_query_params = self._get_redirect_query_params(response)<br/>    <br/>        saved.update(self._save_value("body", body))<br/>        saved.update(self._save_value("headers", response.headers))<br/>        saved.update(self._save_value("redirect_query_params", redirect_query_params))<br/>    <br/>        for cookie in self.expected.get("cookies", []):<br/>            if cookie not in response.cookies:<br/>                self._adderr("No cookie named '%s' in response", cookie)<br/>    <br/>        try:<br/>            wrapped = get_wrapped_response_function(self.expected["save"]["$ext"])<br/>        except KeyError:<br/>            logger.debug("No save function for this stage")<br/>        else:<br/>            try:<br/>                to_save = wrapped(response)<br/>            except Exception as e: #pylint: disable=broad-except<br/>                self._adderr("Error calling save function '%s':\n%s",<br/>                    wrapped.func,<br/>                    indent_err_text(traceback.format_exc()),<br/>                    e=e)<br/>            else:<br/>                if isinstance(to_save, dict):<br/>                    saved.update(to_save)<br/>                elif to_save is not None:<br/>                    self._adderr("Unexpected return value '%s' from $ext save function")<br/>    <br/>        self._validate_block("body", body)<br/>        self._validate_block("headers", response.headers)<br/>        self._validate_block("redirect_query_params", redirect_query_params)<br/>    <br/>        if self.errors:<br/>&gt;           raise TestFailError("Test '{:s}' failed:\n{:s}".format(self.name, self._str_errors()), failures=self.errors)<br/><span class="error">E           TestFailError: Test 'Both CurrentBlockHeight and HeaderHash are changing frequently.' failed:</span><br/><span class="error">E           - Value mismatch in body: Key mismatch: (expected["result"]["header"]["StateHash"] = '0x60ab615b3010eb7f35cdc85e811b22876c0636809c06809030654a55e95bf1ca', actual["result"]["header"]["StateHash"] = '0x0a8ec89d8a6dfed0681157c3a2ef3547df99b28933b4450d3b0b423f47478bad')</span><br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/tavern/_plugins/rest/response.py:207: TestFailError<br/>------------------------------ Captured log call -------------------------------<br/>dict_util.py               292 WARNING  Structure of returned data was different than expected  - Extra keys in response: set([u'totalDifficulty', u'txDebts', u'transactions']) (expected["result"] = '{'header': {'StateHash': '0x60ab615b3010eb7f35cdc85e811b22876c0636809c06809030654a55e95bf1ca', 'PreviousBlockHash': '0x0000041658ae95e8737dfae3dd968398846dd380c7c145379178276cb76146e0', 'TxHash': '0xe800199189634548e10c97e7cc70f79623f0740b4f19872fcf1559a8fbf98295', 'Creator': '0xe2bbc9fadb4c9d78ad2da944ccb408ff55de3931'}, 'debts': [], 'hash': '0x000002dbbe5ed3d36b7ae3e1d3f9a3a5191aaaf1db740afa68b4db2ff355bc79'}', actual["result"] = '{u'hash': u'0x0000006c89e1a3d3246c9a9f5a73fc3f8f70b16c4fb6e08cd055d94dbcc12f66', u'transactions': [{u'hash': u'0xb5bad5e072f41a108bb2fc157231deb130e3c1ccdcedea249855ae4da1a45313', u'gasLimit': 0, u'to': u'0x0ea2a45ab5a909c309439b0e004c61b7b2a3e831', u'amount': 150000000, u'accountNonce': 0, u'from': u'0x0000000000000000000000000000000000000000', u'payload': u'', u'gasPrice': 0}], u'debts': [], u'header': {u'StateHash': u'0x0a8ec89d8a6dfed0681157c3a2ef3547df99b28933b4450d3b0b423f47478bad', u'PreviousBlockHash': u'0x000001d1f74bb83b00bc2d585c013e4e692a6a45aae13d29d839f655f7c11118', u'Creator': u'0x0ea2a45ab5a909c309439b0e004c61b7b2a3e831', u'ExtraData': u'', u'Height': 10368, u'Consensus': 0, u'Difficulty': 3535545, u'TxHash': u'0x235de77725481c27a3529d87d262d349fea7f0d142eaf1239ebf908722e781a7', u'CreateTimestamp': 1543451366, u'TxDebtHash': u'0x0000000000000000000000000000000000000000000000000000000000000000', u'ReceiptHash': u'0x8bcadf05baece9ca77778f46773d401a44c14129242f37866434f0d51c7c3d3e', u'DebtHash': u'0x0000000000000000000000000000000000000000000000000000000000000000', u'Witness': u'MTM3OTE4MjIzMjM3NzQwMTEyMjc='}, u'txDebts': [], u'totalDifficulty': 41272163186}')
Traceback (most recent call last):
  File "/Users/frank/venv/testEnv/lib/python2.7/site-packages/tavern/util/dict_util.py", line 259, in check_keys_match_recursive
    assert actual_val == expected_val
AssertionError: assert {'debts': [],...72163186, ...} == {'debts': [], ...9a8fbf98295'}}
  Omitting 1 identical items, use -vv to show
  Differing items:
  {'header': {'Consensus': 0, 'CreateTimestamp': 1543451366, 'Creator': '0x0ea2a45ab5a909c309439b0e004c61b7b2a3e831', 'DebtHash': '0x0000000000000000000000000000000000000000000000000000000000000000', ...}} != {'header': {'Creator': '0xe2bbc9fadb4c9d78ad2da944ccb408ff55de3931', 'PreviousBlockHash': '0x0000041658ae95e8737dfae3d...22876c0636809c06809030654a55e95bf1ca', 'TxHash': '0xe800199189634548e10c97e7cc70f79623f0740b4f19872fcf1559a8fbf98295'}}
  {'hash': '0x0000006c89e1a3d3246c9a9f5a73fc3f8f70b16c4fb6e08cd055d94db...
  
  ...Full output truncated (13 lines hidden), use '-vv' to show
dict_util.py               292 WARNING  Structure of returned data was different than expected  - Extra keys in response: set([u'ExtraData', u'Height', u'Consensus', u'Difficulty', u'CreateTimestamp', u'TxDebtHash', u'ReceiptHash', u'DebtHash', u'Witness']) (expected["result"]["header"] = '{'StateHash': '0x60ab615b3010eb7f35cdc85e811b22876c0636809c06809030654a55e95bf1ca', 'PreviousBlockHash': '0x0000041658ae95e8737dfae3dd968398846dd380c7c145379178276cb76146e0', 'TxHash': '0xe800199189634548e10c97e7cc70f79623f0740b4f19872fcf1559a8fbf98295', 'Creator': '0xe2bbc9fadb4c9d78ad2da944ccb408ff55de3931'}', actual["result"]["header"] = '{u'StateHash': u'0x0a8ec89d8a6dfed0681157c3a2ef3547df99b28933b4450d3b0b423f47478bad', u'PreviousBlockHash': u'0x000001d1f74bb83b00bc2d585c013e4e692a6a45aae13d29d839f655f7c11118', u'Creator': u'0x0ea2a45ab5a909c309439b0e004c61b7b2a3e831', u'ExtraData': u'', u'Height': 10368, u'Consensus': 0, u'Difficulty': 3535545, u'TxHash': u'0x235de77725481c27a3529d87d262d349fea7f0d142eaf1239ebf908722e781a7', u'CreateTimestamp': 1543451366, u'TxDebtHash': u'0x0000000000000000000000000000000000000000000000000000000000000000', u'ReceiptHash': u'0x8bcadf05baece9ca77778f46773d401a44c14129242f37866434f0d51c7c3d3e', u'DebtHash': u'0x0000000000000000000000000000000000000000000000000000000000000000', u'Witness': u'MTM3OTE4MjIzMjM3NzQwMTEyMjc='}')
Traceback (most recent call last):
  File "/Users/frank/venv/testEnv/lib/python2.7/site-packages/tavern/util/dict_util.py", line 259, in check_keys_match_recursive
    assert actual_val == expected_val
AssertionError: assert {'Consensus':...0000000', ...} == {'Creator': '0...59a8fbf98295'}
  Differing items:
  {'StateHash': '0x0a8ec89d8a6dfed0681157c3a2ef3547df99b28933b4450d3b0b423f47478bad'} != {'StateHash': '0x60ab615b3010eb7f35cdc85e811b22876c0636809c06809030654a55e95bf1ca'}
  {'PreviousBlockHash': '0x000001d1f74bb83b00bc2d585c013e4e692a6a45aae13d29d839f655f7c11118'} != {'PreviousBlockHash': '0x0000041658ae95e8737dfae3dd968398846dd380c7c145379178276cb76146e0'}
  {'TxHash': '0x235de77725481c27a3529d87d262d349fea7f0d142eaf1239ebf908722e781a7'} != {'TxHash': '0xe800199189634548e10c97e7cc70f79623f0740b4f19872fcf1559a8fbf98295'}
  {'Creator': '0x0ea2a45ab5a909c309439b0e...
  
  ...Full output truncated (12 lines hidden), use '-vv' to show
base.py                     37 ERROR    Value mismatch in body: Key mismatch: (expected["result"]["header"]["StateHash"] = '0x60ab615b3010eb7f35cdc85e811b22876c0636809c06809030654a55e95bf1ca', actual["result"]["header"]["StateHash"] = '0x0a8ec89d8a6dfed0681157c3a2ef3547df99b28933b4450d3b0b423f47478bad')</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">http/test_getBlockByHeight.tavern.yaml::This method is used to obtain the block content based on block height.</td>
          <td class="col-duration">0.10</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;CallInfo when='call' exception: Test 'Both CurrentBlockHeight and HeaderHash ...Hash"] = '0x000001d1f74bb83b00bc2d585c013e4e692a6a45aae13d29d839f655f7c11118')&gt;<br/>func = &lt;function &lt;lambda&gt; at 0x10c51ae60&gt;, when = 'call', treat_keyboard_interrupt_as_exception = False<br/><br/>    def __init__(self, func, when, treat_keyboard_interrupt_as_exception=False):<br/>        #: context of invocation: one of "setup", "call",<br/>        #: "teardown", "memocollect"<br/>        self.when = when<br/>        self.start = time()<br/>        try:<br/>&gt;           self.result = func()<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/_pytest/runner.py:211: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>&gt;       lambda: ihook(item=item, **kwds),<br/>        when=when,<br/>        treat_keyboard_interrupt_as_exception=item.config.getvalue("usepdb"),<br/>    )<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/_pytest/runner.py:193: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;_HookCaller 'pytest_runtest_call'&gt;, args = (), kwargs = {'item': &lt;YamlItem 'This method is used to obtain the block content based on block height.'&gt;}, notincall = set([])<br/><br/>    def __call__(self, *args, **kwargs):<br/>        if args:<br/>            raise TypeError("hook calling supports only keyword arguments")<br/>        assert not self.is_historic()<br/>        if self.spec and self.spec.argnames:<br/>            notincall = (<br/>                set(self.spec.argnames) - set(["__multicall__"]) - set(kwargs.keys())<br/>            )<br/>            if notincall:<br/>                warnings.warn(<br/>                    "Argument(s) {} which are declared in the hookspec "<br/>                    "can not be found in this hook call".format(tuple(notincall)),<br/>                    stacklevel=2,<br/>                )<br/>&gt;       return self._hookexec(self, self.get_hookimpls(), kwargs)<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/pluggy/hooks.py:284: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;_pytest.config.PytestPluginManager object at 0x10b920590&gt;, hook = &lt;_HookCaller 'pytest_runtest_call'&gt;<br/>methods = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/Users/frank/venv/testEnv/lib/python2.7/site-pa...t 0x10bee0c10&gt;&gt;, &lt;HookImpl plugin_name='logging-plugin', plugin=&lt;_pytest.logging.LoggingPlugin object at 0x10bf06f50&gt;&gt;]<br/>kwargs = {'item': &lt;YamlItem 'This method is used to obtain the block content based on block height.'&gt;}<br/><br/>    def _hookexec(self, hook, methods, kwargs):<br/>        # called from all hookcaller instances.<br/>        # enable_tracing will set its own wrapping function at self._inner_hookexec<br/>&gt;       return self._inner_hookexec(hook, methods, kwargs)<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/pluggy/manager.py:67: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>hook = &lt;_HookCaller 'pytest_runtest_call'&gt;<br/>methods = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/Users/frank/venv/testEnv/lib/python2.7/site-pa...t 0x10bee0c10&gt;&gt;, &lt;HookImpl plugin_name='logging-plugin', plugin=&lt;_pytest.logging.LoggingPlugin object at 0x10bf06f50&gt;&gt;]<br/>kwargs = {'item': &lt;YamlItem 'This method is used to obtain the block content based on block height.'&gt;}<br/><br/>    self._inner_hookexec = lambda hook, methods, kwargs: hook.multicall(<br/>        methods,<br/>        kwargs,<br/>&gt;       firstresult=hook.spec.opts.get("firstresult") if hook.spec else False,<br/>    )<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/pluggy/manager.py:61: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>hook_impls = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/Users/frank/venv/testEnv/lib/python2.7/site-pa...t 0x10bee0c10&gt;&gt;, &lt;HookImpl plugin_name='logging-plugin', plugin=&lt;_pytest.logging.LoggingPlugin object at 0x10bf06f50&gt;&gt;]<br/>caller_kwargs = {'item': &lt;YamlItem 'This method is used to obtain the block content based on block height.'&gt;}, firstresult = False<br/><br/>    def _multicall(hook_impls, caller_kwargs, firstresult=False):<br/>        """Execute a call into multiple python functions/methods and return the<br/>        result(s).<br/>    <br/>        ``caller_kwargs`` comes from _HookCaller.__call__().<br/>        """<br/>        __tracebackhide__ = True<br/>        results = []<br/>        excinfo = None<br/>        try:  # run impl and wrapper setup functions in a loop<br/>            teardowns = []<br/>            try:<br/>                for hook_impl in reversed(hook_impls):<br/>                    try:<br/>                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]<br/>                    except KeyError:<br/>                        for argname in hook_impl.argnames:<br/>                            if argname not in caller_kwargs:<br/>                                raise HookCallError(<br/>                                    "hook call must provide argument %r" % (argname,)<br/>                                )<br/>    <br/>                    if hook_impl.hookwrapper:<br/>                        try:<br/>                            gen = hook_impl.function(*args)<br/>                            next(gen)  # first yield<br/>                            teardowns.append(gen)<br/>                        except StopIteration:<br/>                            _raise_wrapfail(gen, "did not yield")<br/>                    else:<br/>                        res = hook_impl.function(*args)<br/>                        if res is not None:<br/>                            results.append(res)<br/>                            if firstresult:  # halt further impl calls<br/>                                break<br/>            except BaseException:<br/>                excinfo = sys.exc_info()<br/>        finally:<br/>            if firstresult:  # first result hooks return a single value<br/>                outcome = _Result(results[0] if results else None, excinfo)<br/>            else:<br/>                outcome = _Result(results, excinfo)<br/>    <br/>            # run all wrapper post-yield blocks<br/>            for gen in reversed(teardowns):<br/>                try:<br/>                    gen.send(outcome)<br/>                    _raise_wrapfail(gen, "has second yield")<br/>                except StopIteration:<br/>                    pass<br/>    <br/>&gt;           return outcome.get_result()<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/pluggy/callers.py:208: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;pluggy.callers._Result object at 0x10cfb77d0&gt;<br/><br/>    def get_result(self):<br/>        """Get the result(s) for this hook call.<br/>    <br/>        If the hook was marked as a ``firstresult`` only a single value<br/>        will be returned otherwise a list of results.<br/>        """<br/>        __tracebackhide__ = True<br/>        if self._excinfo is None:<br/>            return self._result<br/>        else:<br/>            ex = self._excinfo<br/>            if _py3:<br/>                raise ex[1].with_traceback(ex[2])<br/>&gt;           _reraise(*ex)  # noqa<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/pluggy/callers.py:81: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>hook_impls = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/Users/frank/venv/testEnv/lib/python2.7/site-pa...t 0x10bee0c10&gt;&gt;, &lt;HookImpl plugin_name='logging-plugin', plugin=&lt;_pytest.logging.LoggingPlugin object at 0x10bf06f50&gt;&gt;]<br/>caller_kwargs = {'item': &lt;YamlItem 'This method is used to obtain the block content based on block height.'&gt;}, firstresult = False<br/><br/>    def _multicall(hook_impls, caller_kwargs, firstresult=False):<br/>        """Execute a call into multiple python functions/methods and return the<br/>        result(s).<br/>    <br/>        ``caller_kwargs`` comes from _HookCaller.__call__().<br/>        """<br/>        __tracebackhide__ = True<br/>        results = []<br/>        excinfo = None<br/>        try:  # run impl and wrapper setup functions in a loop<br/>            teardowns = []<br/>            try:<br/>                for hook_impl in reversed(hook_impls):<br/>                    try:<br/>                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]<br/>                    except KeyError:<br/>                        for argname in hook_impl.argnames:<br/>                            if argname not in caller_kwargs:<br/>                                raise HookCallError(<br/>                                    "hook call must provide argument %r" % (argname,)<br/>                                )<br/>    <br/>                    if hook_impl.hookwrapper:<br/>                        try:<br/>                            gen = hook_impl.function(*args)<br/>                            next(gen)  # first yield<br/>                            teardowns.append(gen)<br/>                        except StopIteration:<br/>                            _raise_wrapfail(gen, "did not yield")<br/>                    else:<br/>&gt;                       res = hook_impl.function(*args)<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/pluggy/callers.py:187: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>item = &lt;YamlItem 'This method is used to obtain the block content based on block height.'&gt;<br/><br/>    def pytest_runtest_call(item):<br/>        _update_current_test_var(item, "call")<br/>        sys.last_type, sys.last_value, sys.last_traceback = (None, None, None)<br/>        try:<br/>&gt;           item.runtest()<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/_pytest/runner.py:121: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;YamlItem 'This method is used to obtain the block content based on block height.'&gt;<br/><br/>    def runtest(self):<br/>        self.global_cfg = self._parse_arguments()<br/>    <br/>        self.global_cfg.setdefault("variables", {})<br/>    <br/>        load_plugins(self.global_cfg)<br/>    <br/>        # INTERNAL<br/>        # NOTE - now that we can 'mark' tests, we could use pytest.mark.xfail<br/>        # instead. This doesn't differentiate between an error in verification<br/>        # and an error when running the test though.<br/>        xfail = self.spec.get("_xfail", False)<br/>    <br/>        try:<br/>            verify_tests(self.spec)<br/>    <br/>            fixture_values = self._load_fixture_values()<br/>            self.global_cfg["variables"].update(fixture_values)<br/>    <br/>&gt;           run_test(self.path, self.spec, self.global_cfg)<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/tavern/testutils/pytesthook.py:431: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>in_file = local('/Users/frank/code/github/api-test/http/test_getBlockByHeight.tavern.yaml')<br/>test_spec = {'stages': [{'request': {'url': '{service.proto:s}://{service.host:s}:{service...ame': 'This method is used to obtain the block content based on block height.'}<br/>global_cfg = {'backends': {'http': 'requests', 'mqtt': 'paho-mqtt'}, 'strict': [], 'variables': {'node': {'Coinbase': '0xe2bbc9fadb...t-type': 'application/json'}, 'json..._TEXT_ENCODING': '0x1F7:0x0:0x0', 'PWD': '/Users/frank/code/github/api-test'}}&gt;}}<br/><br/>    def run_test(in_file, test_spec, global_cfg):<br/>        """Run a single tavern test<br/>    <br/>        Note that each tavern test can consist of multiple requests (log in,<br/>        create, update, delete, etc).<br/>    <br/>        The global configuration is copied and used as an initial configuration for<br/>        this test. Any values which are saved from any tests are saved into this<br/>        test block and can be used for formatting in later stages in the test.<br/>    <br/>        Args:<br/>            in_file (str): filename containing this test<br/>            test_spec (dict): The specification for this test<br/>            global_cfg (dict): Any global configuration for this test<br/>    <br/>        No Longer Raises:<br/>            TavernException: If any of the tests failed<br/>        """<br/>    <br/>        # pylint: disable=too-many-locals<br/>    <br/>        # Initialise test config for this test with the global configuration before<br/>        # starting<br/>        test_block_config = dict(global_cfg)<br/>    <br/>        if "variables" not in test_block_config:<br/>            test_block_config["variables"] = {}<br/>    <br/>        tavern_box = Box({<br/>            "env_vars": dict(os.environ),<br/>        })<br/>    <br/>        if not test_spec:<br/>            logger.warning("Empty test block in %s", in_file)<br/>            return<br/>    <br/>        available_stages = {}<br/>        if test_spec.get("includes"):<br/>            for included in test_spec["includes"]:<br/>                if "variables" in included:<br/>                    formatted_include = format_keys(included["variables"], {"tavern": tavern_box})<br/>                    test_block_config["variables"].update(formatted_include)<br/>    <br/>                if "stages" in included:<br/>                    for stage in included["stages"]:<br/>                        if stage["id"] in available_stages:<br/>                            raise exceptions.DuplicateStageDefinitionError(<br/>                                "Stage with specified id already defined: {}".format(stage["id"]))<br/>                        available_stages[stage["id"]] = stage<br/>    <br/>        test_block_config["variables"]["tavern"] = tavern_box<br/>    <br/>        test_block_name = test_spec["test_name"]<br/>    <br/>        # Strict on body by default<br/>        default_strictness = test_block_config["strict"]<br/>    <br/>        logger.info("Running test : %s", test_block_name)<br/>    <br/>        with ExitStack() as stack:<br/>            test_spec["stages"] = _resolve_test_stages(test_spec, available_stages)<br/>            sessions = get_extra_sessions(test_spec, test_block_config)<br/>    <br/>            for name, session in sessions.items():<br/>                logger.debug("Entering context for %s", name)<br/>                stack.enter_context(session)<br/>    <br/>            # Run tests in a path in order<br/>            for stage in test_spec["stages"]:<br/>                if stage.get('skip'):<br/>                    continue<br/>    <br/>                test_block_config["strict"] = default_strictness<br/>    <br/>                # Can be overridden per stage<br/>                # NOTE<br/>                # this is hardcoded to check for the 'response' block. In the far<br/>                # future there might not be a response block, but at the moment it<br/>                # is the hardcoded value for any HTTP request.<br/>                if stage.get("response", {}):<br/>                    if stage.get("response").get("strict", None) is not None:<br/>                        stage_strictness = stage.get("response").get("strict", None)<br/>                    elif test_spec.get("strict", None) is not None:<br/>                        stage_strictness = test_spec.get("strict", None)<br/>                    else:<br/>                        stage_strictness = default_strictness<br/>    <br/>                    logger.debug("Strict key checking for this stage is '%s'", stage_strictness)<br/>    <br/>                    test_block_config["strict"] = stage_strictness<br/>                elif default_strictness:<br/>                    logger.debug("Default strictness '%s' ignored for this stage", default_strictness)<br/>    <br/>                run_stage_ = run_stage<br/>                if stage.get('max_retries'):<br/>                    run_stage_ = retry(stage)(run_stage_)<br/>    <br/>                try:<br/>&gt;                   run_stage_(sessions, stage, tavern_box, test_block_config)<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/tavern/core.py:145: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>sessions = {'requests': &lt;requests.sessions.Session object at 0x10c14ba50&gt;}<br/>stage = {'request': {'url': '{service.proto:s}://{service.host:s}:{service.port:d}', '...5ed3d36b7ae3e1d3f9a3a5191aaaf1db740afa68b4db2ff355bc79'}}, 'status_code': 200}}<br/>tavern_box = &lt;Box: {'request_vars': {'headers': {'content-type': 'application/json'}, 'json..._TEXT_ENCODING': '0x1F7:0x0:0x0', 'PWD': '/Users/frank/code/github/api-test'}}&gt;<br/>test_block_config = {'backends': {'http': 'requests', 'mqtt': 'paho-mqtt'}, 'strict': [], 'variables': {'node': {'Coinbase': '0xe2bbc9fadb...t-type': 'application/json'}, 'json..._TEXT_ENCODING': '0x1F7:0x0:0x0', 'PWD': '/Users/frank/code/github/api-test'}}&gt;}}<br/><br/>    def run_stage(sessions, stage, tavern_box, test_block_config):<br/>        """Run one stage from the test<br/>    <br/>        Args:<br/>            sessions (list): List of relevant 'session' objects used for this test<br/>            stage (dict): specification of stage to be run<br/>            tavern_box (box.Box): Box object containing format variables to be used<br/>                in test<br/>            test_block_config (dict): available variables for test<br/>        """<br/>        name = stage["name"]<br/>    <br/>        r = get_request_type(stage, test_block_config, sessions)<br/>    <br/>        tavern_box.update(request_vars=r.request_vars)<br/>    <br/>        expected = get_expected(stage, test_block_config, sessions)<br/>    <br/>        delay(stage, "before")<br/>    <br/>        logger.info("Running stage : %s", name)<br/>        response = r.run()<br/>    <br/>        verifiers = get_verifiers(stage, test_block_config, sessions, expected)<br/>        for v in verifiers:<br/>&gt;           saved = v.verify(response)<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/tavern/core.py:180: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;tavern._plugins.rest.response.RestResponse object at 0x10cfbeb50&gt;, response = &lt;Response [200]&gt;<br/><br/>    def verify(self, response):<br/>        """Verify response against expected values and returns any values that<br/>        we wanted to save for use in future requests<br/>    <br/>        There are various ways to 'validate' a block - a specific function, just<br/>        matching values, validating a schema, etc...<br/>    <br/>        Args:<br/>            response (requests.Response): response object<br/>    <br/>        Returns:<br/>            dict: Any saved values<br/>    <br/>        Raises:<br/>            TestFailError: Something went wrong with validating the response<br/>        """<br/>        # pylint: disable=too-many-statements<br/>    <br/>        self._verbose_log_response(response)<br/>    <br/>        self.response = response<br/>        self.status_code = response.status_code<br/>    <br/>        try:<br/>            body = response.json()<br/>        except ValueError:<br/>            body = None<br/>    <br/>        self._check_status_code(response.status_code, body)<br/>    <br/>        if self.validate_function:<br/>            try:<br/>                self.validate_function(response)<br/>            except Exception as e: #pylint: disable=broad-except<br/>                self._adderr("Error calling validate function '%s':\n%s",<br/>                    self.validate_function.func,<br/>                    indent_err_text(traceback.format_exc()),<br/>                    e=e)<br/>    <br/>        # Get any keys to save<br/>        saved = {}<br/>    <br/>        redirect_query_params = self._get_redirect_query_params(response)<br/>    <br/>        saved.update(self._save_value("body", body))<br/>        saved.update(self._save_value("headers", response.headers))<br/>        saved.update(self._save_value("redirect_query_params", redirect_query_params))<br/>    <br/>        for cookie in self.expected.get("cookies", []):<br/>            if cookie not in response.cookies:<br/>                self._adderr("No cookie named '%s' in response", cookie)<br/>    <br/>        try:<br/>            wrapped = get_wrapped_response_function(self.expected["save"]["$ext"])<br/>        except KeyError:<br/>            logger.debug("No save function for this stage")<br/>        else:<br/>            try:<br/>                to_save = wrapped(response)<br/>            except Exception as e: #pylint: disable=broad-except<br/>                self._adderr("Error calling save function '%s':\n%s",<br/>                    wrapped.func,<br/>                    indent_err_text(traceback.format_exc()),<br/>                    e=e)<br/>            else:<br/>                if isinstance(to_save, dict):<br/>                    saved.update(to_save)<br/>                elif to_save is not None:<br/>                    self._adderr("Unexpected return value '%s' from $ext save function")<br/>    <br/>        self._validate_block("body", body)<br/>        self._validate_block("headers", response.headers)<br/>        self._validate_block("redirect_query_params", redirect_query_params)<br/>    <br/>        if self.errors:<br/>&gt;           raise TestFailError("Test '{:s}' failed:\n{:s}".format(self.name, self._str_errors()), failures=self.errors)<br/><span class="error">E           TestFailError: Test 'Both CurrentBlockHeight and HeaderHash are changing frequently.' failed:</span><br/><span class="error">E           - Value mismatch in body: Key mismatch: (expected["result"]["header"]["PreviousBlockHash"] = '0x0000041658ae95e8737dfae3dd968398846dd380c7c145379178276cb76146e0', actual["result"]["header"]["PreviousBlockHash"] = '0x000001d1f74bb83b00bc2d585c013e4e692a6a45aae13d29d839f655f7c11118')</span><br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/tavern/_plugins/rest/response.py:207: TestFailError<br/>------------------------------ Captured log call -------------------------------<br/>dict_util.py               292 WARNING  Structure of returned data was different than expected  - Extra keys in response: set([u'totalDifficulty', u'txDebts', u'transactions']) (expected["result"] = '{'header': {'PreviousBlockHash': '0x0000041658ae95e8737dfae3dd968398846dd380c7c145379178276cb76146e0'}, 'debts': [], 'hash': '0x000002dbbe5ed3d36b7ae3e1d3f9a3a5191aaaf1db740afa68b4db2ff355bc79'}', actual["result"] = '{u'hash': u'0x0000006c89e1a3d3246c9a9f5a73fc3f8f70b16c4fb6e08cd055d94dbcc12f66', u'transactions': [{u'hash': u'0xb5bad5e072f41a108bb2fc157231deb130e3c1ccdcedea249855ae4da1a45313', u'gasLimit': 0, u'to': u'0x0ea2a45ab5a909c309439b0e004c61b7b2a3e831', u'amount': 150000000, u'accountNonce': 0, u'from': u'0x0000000000000000000000000000000000000000', u'payload': u'', u'gasPrice': 0}], u'debts': [], u'header': {u'StateHash': u'0x0a8ec89d8a6dfed0681157c3a2ef3547df99b28933b4450d3b0b423f47478bad', u'PreviousBlockHash': u'0x000001d1f74bb83b00bc2d585c013e4e692a6a45aae13d29d839f655f7c11118', u'Creator': u'0x0ea2a45ab5a909c309439b0e004c61b7b2a3e831', u'ExtraData': u'', u'Height': 10368, u'Consensus': 0, u'Difficulty': 3535545, u'TxHash': u'0x235de77725481c27a3529d87d262d349fea7f0d142eaf1239ebf908722e781a7', u'CreateTimestamp': 1543451366, u'TxDebtHash': u'0x0000000000000000000000000000000000000000000000000000000000000000', u'ReceiptHash': u'0x8bcadf05baece9ca77778f46773d401a44c14129242f37866434f0d51c7c3d3e', u'DebtHash': u'0x0000000000000000000000000000000000000000000000000000000000000000', u'Witness': u'MTM3OTE4MjIzMjM3NzQwMTEyMjc='}, u'txDebts': [], u'totalDifficulty': 41272163186}')
Traceback (most recent call last):
  File "/Users/frank/venv/testEnv/lib/python2.7/site-packages/tavern/util/dict_util.py", line 259, in check_keys_match_recursive
    assert actual_val == expected_val
AssertionError: assert {'debts': [],...72163186, ...} == {'debts': [], ...76cb76146e0'}}
  Omitting 1 identical items, use -vv to show
  Differing items:
  {'header': {'Consensus': 0, 'CreateTimestamp': 1543451366, 'Creator': '0x0ea2a45ab5a909c309439b0e004c61b7b2a3e831', 'DebtHash': '0x0000000000000000000000000000000000000000000000000000000000000000', ...}} != {'header': {'PreviousBlockHash': '0x0000041658ae95e8737dfae3dd968398846dd380c7c145379178276cb76146e0'}}
  {'hash': '0x0000006c89e1a3d3246c9a9f5a73fc3f8f70b16c4fb6e08cd055d94dbcc12f66'} != {'hash': '0x000002dbbe5ed3d36b7ae3e1d3f9a3a5191aaaf1db740afa68b4db2ff355bc79'}
  Left contains more items:
  {u'totalDifficulty': ...
  
  ...Full output truncated (11 lines hidden), use '-vv' to show
dict_util.py               292 WARNING  Structure of returned data was different than expected  - Extra keys in response: set([u'StateHash', u'Creator', u'ExtraData', u'Height', u'Consensus', u'Difficulty', u'TxHash', u'CreateTimestamp', u'TxDebtHash', u'ReceiptHash', u'DebtHash', u'Witness']) (expected["result"]["header"] = '{'PreviousBlockHash': '0x0000041658ae95e8737dfae3dd968398846dd380c7c145379178276cb76146e0'}', actual["result"]["header"] = '{u'StateHash': u'0x0a8ec89d8a6dfed0681157c3a2ef3547df99b28933b4450d3b0b423f47478bad', u'PreviousBlockHash': u'0x000001d1f74bb83b00bc2d585c013e4e692a6a45aae13d29d839f655f7c11118', u'Creator': u'0x0ea2a45ab5a909c309439b0e004c61b7b2a3e831', u'ExtraData': u'', u'Height': 10368, u'Consensus': 0, u'Difficulty': 3535545, u'TxHash': u'0x235de77725481c27a3529d87d262d349fea7f0d142eaf1239ebf908722e781a7', u'CreateTimestamp': 1543451366, u'TxDebtHash': u'0x0000000000000000000000000000000000000000000000000000000000000000', u'ReceiptHash': u'0x8bcadf05baece9ca77778f46773d401a44c14129242f37866434f0d51c7c3d3e', u'DebtHash': u'0x0000000000000000000000000000000000000000000000000000000000000000', u'Witness': u'MTM3OTE4MjIzMjM3NzQwMTEyMjc='}')
Traceback (most recent call last):
  File "/Users/frank/venv/testEnv/lib/python2.7/site-packages/tavern/util/dict_util.py", line 259, in check_keys_match_recursive
    assert actual_val == expected_val
AssertionError: assert {'Consensus':...0000000', ...} == {'PreviousBloc...276cb76146e0'}
  Differing items:
  {'PreviousBlockHash': '0x000001d1f74bb83b00bc2d585c013e4e692a6a45aae13d29d839f655f7c11118'} != {'PreviousBlockHash': '0x0000041658ae95e8737dfae3dd968398846dd380c7c145379178276cb76146e0'}
  Left contains more items:
  {u'Consensus': 0,
   u'CreateTimestamp': 1543451366,
   u'Creator': u'0x0ea2a45ab5a909c309439b0e004c61b7b2a3e831',
   u'DebtHash': u'0x0000000000000000000000000000000000000000000000000000000000000000',...
  
  ...Full output truncated (10 lines hidden), use '-vv' to show
base.py                     37 ERROR    Value mismatch in body: Key mismatch: (expected["result"]["header"]["PreviousBlockHash"] = '0x0000041658ae95e8737dfae3dd968398846dd380c7c145379178276cb76146e0', actual["result"]["header"]["PreviousBlockHash"] = '0x000001d1f74bb83b00bc2d585c013e4e692a6a45aae13d29d839f655f7c11118')</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">http/test_getInfo.tavern.yaml::This method returns the node information.</td>
          <td class="col-duration">0.10</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;CallInfo when='call' exception: Test 'Both CurrentBlockHeight and HeaderHash ...mismatch: (expected["result"]["Shard"] = '1', actual["result"]["Shard"] = '2')&gt;<br/>func = &lt;function &lt;lambda&gt; at 0x10c3af8c0&gt;, when = 'call', treat_keyboard_interrupt_as_exception = False<br/><br/>    def __init__(self, func, when, treat_keyboard_interrupt_as_exception=False):<br/>        #: context of invocation: one of "setup", "call",<br/>        #: "teardown", "memocollect"<br/>        self.when = when<br/>        self.start = time()<br/>        try:<br/>&gt;           self.result = func()<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/_pytest/runner.py:211: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>&gt;       lambda: ihook(item=item, **kwds),<br/>        when=when,<br/>        treat_keyboard_interrupt_as_exception=item.config.getvalue("usepdb"),<br/>    )<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/_pytest/runner.py:193: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;_HookCaller 'pytest_runtest_call'&gt;, args = (), kwargs = {'item': &lt;YamlItem 'This method returns the node information.'&gt;}, notincall = set([])<br/><br/>    def __call__(self, *args, **kwargs):<br/>        if args:<br/>            raise TypeError("hook calling supports only keyword arguments")<br/>        assert not self.is_historic()<br/>        if self.spec and self.spec.argnames:<br/>            notincall = (<br/>                set(self.spec.argnames) - set(["__multicall__"]) - set(kwargs.keys())<br/>            )<br/>            if notincall:<br/>                warnings.warn(<br/>                    "Argument(s) {} which are declared in the hookspec "<br/>                    "can not be found in this hook call".format(tuple(notincall)),<br/>                    stacklevel=2,<br/>                )<br/>&gt;       return self._hookexec(self, self.get_hookimpls(), kwargs)<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/pluggy/hooks.py:284: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;_pytest.config.PytestPluginManager object at 0x10b920590&gt;, hook = &lt;_HookCaller 'pytest_runtest_call'&gt;<br/>methods = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/Users/frank/venv/testEnv/lib/python2.7/site-pa...t 0x10bee0c10&gt;&gt;, &lt;HookImpl plugin_name='logging-plugin', plugin=&lt;_pytest.logging.LoggingPlugin object at 0x10bf06f50&gt;&gt;]<br/>kwargs = {'item': &lt;YamlItem 'This method returns the node information.'&gt;}<br/><br/>    def _hookexec(self, hook, methods, kwargs):<br/>        # called from all hookcaller instances.<br/>        # enable_tracing will set its own wrapping function at self._inner_hookexec<br/>&gt;       return self._inner_hookexec(hook, methods, kwargs)<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/pluggy/manager.py:67: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>hook = &lt;_HookCaller 'pytest_runtest_call'&gt;<br/>methods = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/Users/frank/venv/testEnv/lib/python2.7/site-pa...t 0x10bee0c10&gt;&gt;, &lt;HookImpl plugin_name='logging-plugin', plugin=&lt;_pytest.logging.LoggingPlugin object at 0x10bf06f50&gt;&gt;]<br/>kwargs = {'item': &lt;YamlItem 'This method returns the node information.'&gt;}<br/><br/>    self._inner_hookexec = lambda hook, methods, kwargs: hook.multicall(<br/>        methods,<br/>        kwargs,<br/>&gt;       firstresult=hook.spec.opts.get("firstresult") if hook.spec else False,<br/>    )<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/pluggy/manager.py:61: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>hook_impls = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/Users/frank/venv/testEnv/lib/python2.7/site-pa...t 0x10bee0c10&gt;&gt;, &lt;HookImpl plugin_name='logging-plugin', plugin=&lt;_pytest.logging.LoggingPlugin object at 0x10bf06f50&gt;&gt;]<br/>caller_kwargs = {'item': &lt;YamlItem 'This method returns the node information.'&gt;}, firstresult = False<br/><br/>    def _multicall(hook_impls, caller_kwargs, firstresult=False):<br/>        """Execute a call into multiple python functions/methods and return the<br/>        result(s).<br/>    <br/>        ``caller_kwargs`` comes from _HookCaller.__call__().<br/>        """<br/>        __tracebackhide__ = True<br/>        results = []<br/>        excinfo = None<br/>        try:  # run impl and wrapper setup functions in a loop<br/>            teardowns = []<br/>            try:<br/>                for hook_impl in reversed(hook_impls):<br/>                    try:<br/>                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]<br/>                    except KeyError:<br/>                        for argname in hook_impl.argnames:<br/>                            if argname not in caller_kwargs:<br/>                                raise HookCallError(<br/>                                    "hook call must provide argument %r" % (argname,)<br/>                                )<br/>    <br/>                    if hook_impl.hookwrapper:<br/>                        try:<br/>                            gen = hook_impl.function(*args)<br/>                            next(gen)  # first yield<br/>                            teardowns.append(gen)<br/>                        except StopIteration:<br/>                            _raise_wrapfail(gen, "did not yield")<br/>                    else:<br/>                        res = hook_impl.function(*args)<br/>                        if res is not None:<br/>                            results.append(res)<br/>                            if firstresult:  # halt further impl calls<br/>                                break<br/>            except BaseException:<br/>                excinfo = sys.exc_info()<br/>        finally:<br/>            if firstresult:  # first result hooks return a single value<br/>                outcome = _Result(results[0] if results else None, excinfo)<br/>            else:<br/>                outcome = _Result(results, excinfo)<br/>    <br/>            # run all wrapper post-yield blocks<br/>            for gen in reversed(teardowns):<br/>                try:<br/>                    gen.send(outcome)<br/>                    _raise_wrapfail(gen, "has second yield")<br/>                except StopIteration:<br/>                    pass<br/>    <br/>&gt;           return outcome.get_result()<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/pluggy/callers.py:208: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;pluggy.callers._Result object at 0x10c4a4f10&gt;<br/><br/>    def get_result(self):<br/>        """Get the result(s) for this hook call.<br/>    <br/>        If the hook was marked as a ``firstresult`` only a single value<br/>        will be returned otherwise a list of results.<br/>        """<br/>        __tracebackhide__ = True<br/>        if self._excinfo is None:<br/>            return self._result<br/>        else:<br/>            ex = self._excinfo<br/>            if _py3:<br/>                raise ex[1].with_traceback(ex[2])<br/>&gt;           _reraise(*ex)  # noqa<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/pluggy/callers.py:81: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>hook_impls = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/Users/frank/venv/testEnv/lib/python2.7/site-pa...t 0x10bee0c10&gt;&gt;, &lt;HookImpl plugin_name='logging-plugin', plugin=&lt;_pytest.logging.LoggingPlugin object at 0x10bf06f50&gt;&gt;]<br/>caller_kwargs = {'item': &lt;YamlItem 'This method returns the node information.'&gt;}, firstresult = False<br/><br/>    def _multicall(hook_impls, caller_kwargs, firstresult=False):<br/>        """Execute a call into multiple python functions/methods and return the<br/>        result(s).<br/>    <br/>        ``caller_kwargs`` comes from _HookCaller.__call__().<br/>        """<br/>        __tracebackhide__ = True<br/>        results = []<br/>        excinfo = None<br/>        try:  # run impl and wrapper setup functions in a loop<br/>            teardowns = []<br/>            try:<br/>                for hook_impl in reversed(hook_impls):<br/>                    try:<br/>                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]<br/>                    except KeyError:<br/>                        for argname in hook_impl.argnames:<br/>                            if argname not in caller_kwargs:<br/>                                raise HookCallError(<br/>                                    "hook call must provide argument %r" % (argname,)<br/>                                )<br/>    <br/>                    if hook_impl.hookwrapper:<br/>                        try:<br/>                            gen = hook_impl.function(*args)<br/>                            next(gen)  # first yield<br/>                            teardowns.append(gen)<br/>                        except StopIteration:<br/>                            _raise_wrapfail(gen, "did not yield")<br/>                    else:<br/>&gt;                       res = hook_impl.function(*args)<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/pluggy/callers.py:187: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>item = &lt;YamlItem 'This method returns the node information.'&gt;<br/><br/>    def pytest_runtest_call(item):<br/>        _update_current_test_var(item, "call")<br/>        sys.last_type, sys.last_value, sys.last_traceback = (None, None, None)<br/>        try:<br/>&gt;           item.runtest()<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/_pytest/runner.py:121: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;YamlItem 'This method returns the node information.'&gt;<br/><br/>    def runtest(self):<br/>        self.global_cfg = self._parse_arguments()<br/>    <br/>        self.global_cfg.setdefault("variables", {})<br/>    <br/>        load_plugins(self.global_cfg)<br/>    <br/>        # INTERNAL<br/>        # NOTE - now that we can 'mark' tests, we could use pytest.mark.xfail<br/>        # instead. This doesn't differentiate between an error in verification<br/>        # and an error when running the test though.<br/>        xfail = self.spec.get("_xfail", False)<br/>    <br/>        try:<br/>            verify_tests(self.spec)<br/>    <br/>            fixture_values = self._load_fixture_values()<br/>            self.global_cfg["variables"].update(fixture_values)<br/>    <br/>&gt;           run_test(self.path, self.spec, self.global_cfg)<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/tavern/testutils/pytesthook.py:431: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>in_file = local('/Users/frank/code/github/api-test/http/test_getInfo.tavern.yaml')<br/>test_spec = {'stages': [{'request': {'url': '{service.proto:s}://{service.host:s}:{service...inst local server'}], 'test_name': 'This method returns the node information.'}<br/>global_cfg = {'backends': {'http': 'requests', 'mqtt': 'paho-mqtt'}, 'strict': [], 'variables': {'node': {'Coinbase': '0xe2bbc9fadb...t-type': 'application/json'}, 'json..._TEXT_ENCODING': '0x1F7:0x0:0x0', 'PWD': '/Users/frank/code/github/api-test'}}&gt;}}<br/><br/>    def run_test(in_file, test_spec, global_cfg):<br/>        """Run a single tavern test<br/>    <br/>        Note that each tavern test can consist of multiple requests (log in,<br/>        create, update, delete, etc).<br/>    <br/>        The global configuration is copied and used as an initial configuration for<br/>        this test. Any values which are saved from any tests are saved into this<br/>        test block and can be used for formatting in later stages in the test.<br/>    <br/>        Args:<br/>            in_file (str): filename containing this test<br/>            test_spec (dict): The specification for this test<br/>            global_cfg (dict): Any global configuration for this test<br/>    <br/>        No Longer Raises:<br/>            TavernException: If any of the tests failed<br/>        """<br/>    <br/>        # pylint: disable=too-many-locals<br/>    <br/>        # Initialise test config for this test with the global configuration before<br/>        # starting<br/>        test_block_config = dict(global_cfg)<br/>    <br/>        if "variables" not in test_block_config:<br/>            test_block_config["variables"] = {}<br/>    <br/>        tavern_box = Box({<br/>            "env_vars": dict(os.environ),<br/>        })<br/>    <br/>        if not test_spec:<br/>            logger.warning("Empty test block in %s", in_file)<br/>            return<br/>    <br/>        available_stages = {}<br/>        if test_spec.get("includes"):<br/>            for included in test_spec["includes"]:<br/>                if "variables" in included:<br/>                    formatted_include = format_keys(included["variables"], {"tavern": tavern_box})<br/>                    test_block_config["variables"].update(formatted_include)<br/>    <br/>                if "stages" in included:<br/>                    for stage in included["stages"]:<br/>                        if stage["id"] in available_stages:<br/>                            raise exceptions.DuplicateStageDefinitionError(<br/>                                "Stage with specified id already defined: {}".format(stage["id"]))<br/>                        available_stages[stage["id"]] = stage<br/>    <br/>        test_block_config["variables"]["tavern"] = tavern_box<br/>    <br/>        test_block_name = test_spec["test_name"]<br/>    <br/>        # Strict on body by default<br/>        default_strictness = test_block_config["strict"]<br/>    <br/>        logger.info("Running test : %s", test_block_name)<br/>    <br/>        with ExitStack() as stack:<br/>            test_spec["stages"] = _resolve_test_stages(test_spec, available_stages)<br/>            sessions = get_extra_sessions(test_spec, test_block_config)<br/>    <br/>            for name, session in sessions.items():<br/>                logger.debug("Entering context for %s", name)<br/>                stack.enter_context(session)<br/>    <br/>            # Run tests in a path in order<br/>            for stage in test_spec["stages"]:<br/>                if stage.get('skip'):<br/>                    continue<br/>    <br/>                test_block_config["strict"] = default_strictness<br/>    <br/>                # Can be overridden per stage<br/>                # NOTE<br/>                # this is hardcoded to check for the 'response' block. In the far<br/>                # future there might not be a response block, but at the moment it<br/>                # is the hardcoded value for any HTTP request.<br/>                if stage.get("response", {}):<br/>                    if stage.get("response").get("strict", None) is not None:<br/>                        stage_strictness = stage.get("response").get("strict", None)<br/>                    elif test_spec.get("strict", None) is not None:<br/>                        stage_strictness = test_spec.get("strict", None)<br/>                    else:<br/>                        stage_strictness = default_strictness<br/>    <br/>                    logger.debug("Strict key checking for this stage is '%s'", stage_strictness)<br/>    <br/>                    test_block_config["strict"] = stage_strictness<br/>                elif default_strictness:<br/>                    logger.debug("Default strictness '%s' ignored for this stage", default_strictness)<br/>    <br/>                run_stage_ = run_stage<br/>                if stage.get('max_retries'):<br/>                    run_stage_ = retry(stage)(run_stage_)<br/>    <br/>                try:<br/>&gt;                   run_stage_(sessions, stage, tavern_box, test_block_config)<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/tavern/core.py:145: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>sessions = {'requests': &lt;requests.sessions.Session object at 0x10c157710&gt;}<br/>stage = {'request': {'url': '{service.proto:s}://{service.host:s}:{service.port:d}', '...node.Coinbase:s}', 'MinerStatus': 'Running', 'Shard': 1}}, 'status_code': 200}}<br/>tavern_box = &lt;Box: {'request_vars': {'headers': {'content-type': 'application/json'}, 'json..._TEXT_ENCODING': '0x1F7:0x0:0x0', 'PWD': '/Users/frank/code/github/api-test'}}&gt;<br/>test_block_config = {'backends': {'http': 'requests', 'mqtt': 'paho-mqtt'}, 'strict': [], 'variables': {'node': {'Coinbase': '0xe2bbc9fadb...t-type': 'application/json'}, 'json..._TEXT_ENCODING': '0x1F7:0x0:0x0', 'PWD': '/Users/frank/code/github/api-test'}}&gt;}}<br/><br/>    def run_stage(sessions, stage, tavern_box, test_block_config):<br/>        """Run one stage from the test<br/>    <br/>        Args:<br/>            sessions (list): List of relevant 'session' objects used for this test<br/>            stage (dict): specification of stage to be run<br/>            tavern_box (box.Box): Box object containing format variables to be used<br/>                in test<br/>            test_block_config (dict): available variables for test<br/>        """<br/>        name = stage["name"]<br/>    <br/>        r = get_request_type(stage, test_block_config, sessions)<br/>    <br/>        tavern_box.update(request_vars=r.request_vars)<br/>    <br/>        expected = get_expected(stage, test_block_config, sessions)<br/>    <br/>        delay(stage, "before")<br/>    <br/>        logger.info("Running stage : %s", name)<br/>        response = r.run()<br/>    <br/>        verifiers = get_verifiers(stage, test_block_config, sessions, expected)<br/>        for v in verifiers:<br/>&gt;           saved = v.verify(response)<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/tavern/core.py:180: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;tavern._plugins.rest.response.RestResponse object at 0x10c4c1fd0&gt;, response = &lt;Response [200]&gt;<br/><br/>    def verify(self, response):<br/>        """Verify response against expected values and returns any values that<br/>        we wanted to save for use in future requests<br/>    <br/>        There are various ways to 'validate' a block - a specific function, just<br/>        matching values, validating a schema, etc...<br/>    <br/>        Args:<br/>            response (requests.Response): response object<br/>    <br/>        Returns:<br/>            dict: Any saved values<br/>    <br/>        Raises:<br/>            TestFailError: Something went wrong with validating the response<br/>        """<br/>        # pylint: disable=too-many-statements<br/>    <br/>        self._verbose_log_response(response)<br/>    <br/>        self.response = response<br/>        self.status_code = response.status_code<br/>    <br/>        try:<br/>            body = response.json()<br/>        except ValueError:<br/>            body = None<br/>    <br/>        self._check_status_code(response.status_code, body)<br/>    <br/>        if self.validate_function:<br/>            try:<br/>                self.validate_function(response)<br/>            except Exception as e: #pylint: disable=broad-except<br/>                self._adderr("Error calling validate function '%s':\n%s",<br/>                    self.validate_function.func,<br/>                    indent_err_text(traceback.format_exc()),<br/>                    e=e)<br/>    <br/>        # Get any keys to save<br/>        saved = {}<br/>    <br/>        redirect_query_params = self._get_redirect_query_params(response)<br/>    <br/>        saved.update(self._save_value("body", body))<br/>        saved.update(self._save_value("headers", response.headers))<br/>        saved.update(self._save_value("redirect_query_params", redirect_query_params))<br/>    <br/>        for cookie in self.expected.get("cookies", []):<br/>            if cookie not in response.cookies:<br/>                self._adderr("No cookie named '%s' in response", cookie)<br/>    <br/>        try:<br/>            wrapped = get_wrapped_response_function(self.expected["save"]["$ext"])<br/>        except KeyError:<br/>            logger.debug("No save function for this stage")<br/>        else:<br/>            try:<br/>                to_save = wrapped(response)<br/>            except Exception as e: #pylint: disable=broad-except<br/>                self._adderr("Error calling save function '%s':\n%s",<br/>                    wrapped.func,<br/>                    indent_err_text(traceback.format_exc()),<br/>                    e=e)<br/>            else:<br/>                if isinstance(to_save, dict):<br/>                    saved.update(to_save)<br/>                elif to_save is not None:<br/>                    self._adderr("Unexpected return value '%s' from $ext save function")<br/>    <br/>        self._validate_block("body", body)<br/>        self._validate_block("headers", response.headers)<br/>        self._validate_block("redirect_query_params", redirect_query_params)<br/>    <br/>        if self.errors:<br/>&gt;           raise TestFailError("Test '{:s}' failed:\n{:s}".format(self.name, self._str_errors()), failures=self.errors)<br/><span class="error">E           TestFailError: Test 'Both CurrentBlockHeight and HeaderHash are changing frequently.' failed:</span><br/><span class="error">E           - Value mismatch in body: Key mismatch: (expected["result"]["Shard"] = '1', actual["result"]["Shard"] = '2')</span><br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/tavern/_plugins/rest/response.py:207: TestFailError<br/>------------------------------ Captured log call -------------------------------<br/>dict_util.py               292 WARNING  Structure of returned data was different than expected  - Extra keys in response: set([u'CurrentBlockHeight', u'HeaderHash']) (expected["result"] = '{'Coinbase': '0xe2bbc9fadb4c9d78ad2da944ccb408ff55de3931', 'MinerStatus': 'Running', 'Shard': 1}', actual["result"] = '{u'Coinbase': u'0x0ea2a45ab5a909c309439b0e004c61b7b2a3e831', u'CurrentBlockHeight': 49423, u'MinerStatus': u'Running', u'Shard': 2, u'HeaderHash': u'0x00000036333ea7b4b0555f81e9af0a01fd500db6f95b6166d3ef06a085271634'}')
Traceback (most recent call last):
  File "/Users/frank/venv/testEnv/lib/python2.7/site-packages/tavern/util/dict_util.py", line 259, in check_keys_match_recursive
    assert actual_val == expected_val
AssertionError: assert {'Coinbase': ...Running', ...} == {'Coinbase': '...', 'Shard': 1}
  Omitting 1 identical items, use -vv to show
  Differing items:
  {'Coinbase': '0x0ea2a45ab5a909c309439b0e004c61b7b2a3e831'} != {'Coinbase': '0xe2bbc9fadb4c9d78ad2da944ccb408ff55de3931'}
  {'Shard': 2} != {'Shard': 1}
  Left contains more items:
  {u'CurrentBlockHeight': 49423,
   u'HeaderHash': u'0x00000036333ea7b4b0555f81e9af0a01fd500db6f95b6166d3ef06a085271634'}...
  
  ...Full output truncated (2 lines hidden), use '-vv' to show
base.py                     37 ERROR    Value mismatch in body: Key mismatch: (expected["result"]["Shard"] = '1', actual["result"]["Shard"] = '2')</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">http/test_getTPS.tavern.yaml::This method returns TPS of seele node.</td>
          <td class="col-duration">0.10</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;CallInfo when='call' exception: Test 'Both CurrentBlockHeight and HeaderHash ...d["result"]["node"] = 'seele node1', actual["result"]["node"] = 'seele node2')&gt;<br/>func = &lt;function &lt;lambda&gt; at 0x10cf0b758&gt;, when = 'call', treat_keyboard_interrupt_as_exception = False<br/><br/>    def __init__(self, func, when, treat_keyboard_interrupt_as_exception=False):<br/>        #: context of invocation: one of "setup", "call",<br/>        #: "teardown", "memocollect"<br/>        self.when = when<br/>        self.start = time()<br/>        try:<br/>&gt;           self.result = func()<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/_pytest/runner.py:211: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>&gt;       lambda: ihook(item=item, **kwds),<br/>        when=when,<br/>        treat_keyboard_interrupt_as_exception=item.config.getvalue("usepdb"),<br/>    )<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/_pytest/runner.py:193: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;_HookCaller 'pytest_runtest_call'&gt;, args = (), kwargs = {'item': &lt;YamlItem 'This method returns TPS of seele node.'&gt;}, notincall = set([])<br/><br/>    def __call__(self, *args, **kwargs):<br/>        if args:<br/>            raise TypeError("hook calling supports only keyword arguments")<br/>        assert not self.is_historic()<br/>        if self.spec and self.spec.argnames:<br/>            notincall = (<br/>                set(self.spec.argnames) - set(["__multicall__"]) - set(kwargs.keys())<br/>            )<br/>            if notincall:<br/>                warnings.warn(<br/>                    "Argument(s) {} which are declared in the hookspec "<br/>                    "can not be found in this hook call".format(tuple(notincall)),<br/>                    stacklevel=2,<br/>                )<br/>&gt;       return self._hookexec(self, self.get_hookimpls(), kwargs)<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/pluggy/hooks.py:284: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;_pytest.config.PytestPluginManager object at 0x10b920590&gt;, hook = &lt;_HookCaller 'pytest_runtest_call'&gt;<br/>methods = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/Users/frank/venv/testEnv/lib/python2.7/site-pa...t 0x10bee0c10&gt;&gt;, &lt;HookImpl plugin_name='logging-plugin', plugin=&lt;_pytest.logging.LoggingPlugin object at 0x10bf06f50&gt;&gt;]<br/>kwargs = {'item': &lt;YamlItem 'This method returns TPS of seele node.'&gt;}<br/><br/>    def _hookexec(self, hook, methods, kwargs):<br/>        # called from all hookcaller instances.<br/>        # enable_tracing will set its own wrapping function at self._inner_hookexec<br/>&gt;       return self._inner_hookexec(hook, methods, kwargs)<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/pluggy/manager.py:67: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>hook = &lt;_HookCaller 'pytest_runtest_call'&gt;<br/>methods = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/Users/frank/venv/testEnv/lib/python2.7/site-pa...t 0x10bee0c10&gt;&gt;, &lt;HookImpl plugin_name='logging-plugin', plugin=&lt;_pytest.logging.LoggingPlugin object at 0x10bf06f50&gt;&gt;]<br/>kwargs = {'item': &lt;YamlItem 'This method returns TPS of seele node.'&gt;}<br/><br/>    self._inner_hookexec = lambda hook, methods, kwargs: hook.multicall(<br/>        methods,<br/>        kwargs,<br/>&gt;       firstresult=hook.spec.opts.get("firstresult") if hook.spec else False,<br/>    )<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/pluggy/manager.py:61: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>hook_impls = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/Users/frank/venv/testEnv/lib/python2.7/site-pa...t 0x10bee0c10&gt;&gt;, &lt;HookImpl plugin_name='logging-plugin', plugin=&lt;_pytest.logging.LoggingPlugin object at 0x10bf06f50&gt;&gt;]<br/>caller_kwargs = {'item': &lt;YamlItem 'This method returns TPS of seele node.'&gt;}, firstresult = False<br/><br/>    def _multicall(hook_impls, caller_kwargs, firstresult=False):<br/>        """Execute a call into multiple python functions/methods and return the<br/>        result(s).<br/>    <br/>        ``caller_kwargs`` comes from _HookCaller.__call__().<br/>        """<br/>        __tracebackhide__ = True<br/>        results = []<br/>        excinfo = None<br/>        try:  # run impl and wrapper setup functions in a loop<br/>            teardowns = []<br/>            try:<br/>                for hook_impl in reversed(hook_impls):<br/>                    try:<br/>                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]<br/>                    except KeyError:<br/>                        for argname in hook_impl.argnames:<br/>                            if argname not in caller_kwargs:<br/>                                raise HookCallError(<br/>                                    "hook call must provide argument %r" % (argname,)<br/>                                )<br/>    <br/>                    if hook_impl.hookwrapper:<br/>                        try:<br/>                            gen = hook_impl.function(*args)<br/>                            next(gen)  # first yield<br/>                            teardowns.append(gen)<br/>                        except StopIteration:<br/>                            _raise_wrapfail(gen, "did not yield")<br/>                    else:<br/>                        res = hook_impl.function(*args)<br/>                        if res is not None:<br/>                            results.append(res)<br/>                            if firstresult:  # halt further impl calls<br/>                                break<br/>            except BaseException:<br/>                excinfo = sys.exc_info()<br/>        finally:<br/>            if firstresult:  # first result hooks return a single value<br/>                outcome = _Result(results[0] if results else None, excinfo)<br/>            else:<br/>                outcome = _Result(results, excinfo)<br/>    <br/>            # run all wrapper post-yield blocks<br/>            for gen in reversed(teardowns):<br/>                try:<br/>                    gen.send(outcome)<br/>                    _raise_wrapfail(gen, "has second yield")<br/>                except StopIteration:<br/>                    pass<br/>    <br/>&gt;           return outcome.get_result()<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/pluggy/callers.py:208: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;pluggy.callers._Result object at 0x10c4aff10&gt;<br/><br/>    def get_result(self):<br/>        """Get the result(s) for this hook call.<br/>    <br/>        If the hook was marked as a ``firstresult`` only a single value<br/>        will be returned otherwise a list of results.<br/>        """<br/>        __tracebackhide__ = True<br/>        if self._excinfo is None:<br/>            return self._result<br/>        else:<br/>            ex = self._excinfo<br/>            if _py3:<br/>                raise ex[1].with_traceback(ex[2])<br/>&gt;           _reraise(*ex)  # noqa<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/pluggy/callers.py:81: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>hook_impls = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/Users/frank/venv/testEnv/lib/python2.7/site-pa...t 0x10bee0c10&gt;&gt;, &lt;HookImpl plugin_name='logging-plugin', plugin=&lt;_pytest.logging.LoggingPlugin object at 0x10bf06f50&gt;&gt;]<br/>caller_kwargs = {'item': &lt;YamlItem 'This method returns TPS of seele node.'&gt;}, firstresult = False<br/><br/>    def _multicall(hook_impls, caller_kwargs, firstresult=False):<br/>        """Execute a call into multiple python functions/methods and return the<br/>        result(s).<br/>    <br/>        ``caller_kwargs`` comes from _HookCaller.__call__().<br/>        """<br/>        __tracebackhide__ = True<br/>        results = []<br/>        excinfo = None<br/>        try:  # run impl and wrapper setup functions in a loop<br/>            teardowns = []<br/>            try:<br/>                for hook_impl in reversed(hook_impls):<br/>                    try:<br/>                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]<br/>                    except KeyError:<br/>                        for argname in hook_impl.argnames:<br/>                            if argname not in caller_kwargs:<br/>                                raise HookCallError(<br/>                                    "hook call must provide argument %r" % (argname,)<br/>                                )<br/>    <br/>                    if hook_impl.hookwrapper:<br/>                        try:<br/>                            gen = hook_impl.function(*args)<br/>                            next(gen)  # first yield<br/>                            teardowns.append(gen)<br/>                        except StopIteration:<br/>                            _raise_wrapfail(gen, "did not yield")<br/>                    else:<br/>&gt;                       res = hook_impl.function(*args)<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/pluggy/callers.py:187: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>item = &lt;YamlItem 'This method returns TPS of seele node.'&gt;<br/><br/>    def pytest_runtest_call(item):<br/>        _update_current_test_var(item, "call")<br/>        sys.last_type, sys.last_value, sys.last_traceback = (None, None, None)<br/>        try:<br/>&gt;           item.runtest()<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/_pytest/runner.py:121: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;YamlItem 'This method returns TPS of seele node.'&gt;<br/><br/>    def runtest(self):<br/>        self.global_cfg = self._parse_arguments()<br/>    <br/>        self.global_cfg.setdefault("variables", {})<br/>    <br/>        load_plugins(self.global_cfg)<br/>    <br/>        # INTERNAL<br/>        # NOTE - now that we can 'mark' tests, we could use pytest.mark.xfail<br/>        # instead. This doesn't differentiate between an error in verification<br/>        # and an error when running the test though.<br/>        xfail = self.spec.get("_xfail", False)<br/>    <br/>        try:<br/>            verify_tests(self.spec)<br/>    <br/>            fixture_values = self._load_fixture_values()<br/>            self.global_cfg["variables"].update(fixture_values)<br/>    <br/>&gt;           run_test(self.path, self.spec, self.global_cfg)<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/tavern/testutils/pytesthook.py:431: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>in_file = local('/Users/frank/code/github/api-test/http/test_getTPS.tavern.yaml')<br/>test_spec = {'stages': [{'request': {'url': '{service.proto:s}://{service.host:s}:{service...against local server'}], 'test_name': 'This method returns TPS of seele node.'}<br/>global_cfg = {'backends': {'http': 'requests', 'mqtt': 'paho-mqtt'}, 'strict': [], 'variables': {'node': {'Coinbase': '0xe2bbc9fadb...t-type': 'application/json'}, 'json..._TEXT_ENCODING': '0x1F7:0x0:0x0', 'PWD': '/Users/frank/code/github/api-test'}}&gt;}}<br/><br/>    def run_test(in_file, test_spec, global_cfg):<br/>        """Run a single tavern test<br/>    <br/>        Note that each tavern test can consist of multiple requests (log in,<br/>        create, update, delete, etc).<br/>    <br/>        The global configuration is copied and used as an initial configuration for<br/>        this test. Any values which are saved from any tests are saved into this<br/>        test block and can be used for formatting in later stages in the test.<br/>    <br/>        Args:<br/>            in_file (str): filename containing this test<br/>            test_spec (dict): The specification for this test<br/>            global_cfg (dict): Any global configuration for this test<br/>    <br/>        No Longer Raises:<br/>            TavernException: If any of the tests failed<br/>        """<br/>    <br/>        # pylint: disable=too-many-locals<br/>    <br/>        # Initialise test config for this test with the global configuration before<br/>        # starting<br/>        test_block_config = dict(global_cfg)<br/>    <br/>        if "variables" not in test_block_config:<br/>            test_block_config["variables"] = {}<br/>    <br/>        tavern_box = Box({<br/>            "env_vars": dict(os.environ),<br/>        })<br/>    <br/>        if not test_spec:<br/>            logger.warning("Empty test block in %s", in_file)<br/>            return<br/>    <br/>        available_stages = {}<br/>        if test_spec.get("includes"):<br/>            for included in test_spec["includes"]:<br/>                if "variables" in included:<br/>                    formatted_include = format_keys(included["variables"], {"tavern": tavern_box})<br/>                    test_block_config["variables"].update(formatted_include)<br/>    <br/>                if "stages" in included:<br/>                    for stage in included["stages"]:<br/>                        if stage["id"] in available_stages:<br/>                            raise exceptions.DuplicateStageDefinitionError(<br/>                                "Stage with specified id already defined: {}".format(stage["id"]))<br/>                        available_stages[stage["id"]] = stage<br/>    <br/>        test_block_config["variables"]["tavern"] = tavern_box<br/>    <br/>        test_block_name = test_spec["test_name"]<br/>    <br/>        # Strict on body by default<br/>        default_strictness = test_block_config["strict"]<br/>    <br/>        logger.info("Running test : %s", test_block_name)<br/>    <br/>        with ExitStack() as stack:<br/>            test_spec["stages"] = _resolve_test_stages(test_spec, available_stages)<br/>            sessions = get_extra_sessions(test_spec, test_block_config)<br/>    <br/>            for name, session in sessions.items():<br/>                logger.debug("Entering context for %s", name)<br/>                stack.enter_context(session)<br/>    <br/>            # Run tests in a path in order<br/>            for stage in test_spec["stages"]:<br/>                if stage.get('skip'):<br/>                    continue<br/>    <br/>                test_block_config["strict"] = default_strictness<br/>    <br/>                # Can be overridden per stage<br/>                # NOTE<br/>                # this is hardcoded to check for the 'response' block. In the far<br/>                # future there might not be a response block, but at the moment it<br/>                # is the hardcoded value for any HTTP request.<br/>                if stage.get("response", {}):<br/>                    if stage.get("response").get("strict", None) is not None:<br/>                        stage_strictness = stage.get("response").get("strict", None)<br/>                    elif test_spec.get("strict", None) is not None:<br/>                        stage_strictness = test_spec.get("strict", None)<br/>                    else:<br/>                        stage_strictness = default_strictness<br/>    <br/>                    logger.debug("Strict key checking for this stage is '%s'", stage_strictness)<br/>    <br/>                    test_block_config["strict"] = stage_strictness<br/>                elif default_strictness:<br/>                    logger.debug("Default strictness '%s' ignored for this stage", default_strictness)<br/>    <br/>                run_stage_ = run_stage<br/>                if stage.get('max_retries'):<br/>                    run_stage_ = retry(stage)(run_stage_)<br/>    <br/>                try:<br/>&gt;                   run_stage_(sessions, stage, tavern_box, test_block_config)<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/tavern/core.py:145: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>sessions = {'requests': &lt;requests.sessions.Session object at 0x10c164cd0&gt;}<br/>stage = {'request': {'url': '{service.proto:s}://{service.host:s}:{service.port:d}', '...o', 'client': '1.0', 'os': 'linux', 'netVersion': '1.0'}}, 'status_code': 200}}<br/>tavern_box = &lt;Box: {'request_vars': {'headers': {'content-type': 'application/json'}, 'json..._TEXT_ENCODING': '0x1F7:0x0:0x0', 'PWD': '/Users/frank/code/github/api-test'}}&gt;<br/>test_block_config = {'backends': {'http': 'requests', 'mqtt': 'paho-mqtt'}, 'strict': [], 'variables': {'node': {'Coinbase': '0xe2bbc9fadb...t-type': 'application/json'}, 'json..._TEXT_ENCODING': '0x1F7:0x0:0x0', 'PWD': '/Users/frank/code/github/api-test'}}&gt;}}<br/><br/>    def run_stage(sessions, stage, tavern_box, test_block_config):<br/>        """Run one stage from the test<br/>    <br/>        Args:<br/>            sessions (list): List of relevant 'session' objects used for this test<br/>            stage (dict): specification of stage to be run<br/>            tavern_box (box.Box): Box object containing format variables to be used<br/>                in test<br/>            test_block_config (dict): available variables for test<br/>        """<br/>        name = stage["name"]<br/>    <br/>        r = get_request_type(stage, test_block_config, sessions)<br/>    <br/>        tavern_box.update(request_vars=r.request_vars)<br/>    <br/>        expected = get_expected(stage, test_block_config, sessions)<br/>    <br/>        delay(stage, "before")<br/>    <br/>        logger.info("Running stage : %s", name)<br/>        response = r.run()<br/>    <br/>        verifiers = get_verifiers(stage, test_block_config, sessions, expected)<br/>        for v in verifiers:<br/>&gt;           saved = v.verify(response)<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/tavern/core.py:180: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;tavern._plugins.rest.response.RestResponse object at 0x10d066290&gt;, response = &lt;Response [200]&gt;<br/><br/>    def verify(self, response):<br/>        """Verify response against expected values and returns any values that<br/>        we wanted to save for use in future requests<br/>    <br/>        There are various ways to 'validate' a block - a specific function, just<br/>        matching values, validating a schema, etc...<br/>    <br/>        Args:<br/>            response (requests.Response): response object<br/>    <br/>        Returns:<br/>            dict: Any saved values<br/>    <br/>        Raises:<br/>            TestFailError: Something went wrong with validating the response<br/>        """<br/>        # pylint: disable=too-many-statements<br/>    <br/>        self._verbose_log_response(response)<br/>    <br/>        self.response = response<br/>        self.status_code = response.status_code<br/>    <br/>        try:<br/>            body = response.json()<br/>        except ValueError:<br/>            body = None<br/>    <br/>        self._check_status_code(response.status_code, body)<br/>    <br/>        if self.validate_function:<br/>            try:<br/>                self.validate_function(response)<br/>            except Exception as e: #pylint: disable=broad-except<br/>                self._adderr("Error calling validate function '%s':\n%s",<br/>                    self.validate_function.func,<br/>                    indent_err_text(traceback.format_exc()),<br/>                    e=e)<br/>    <br/>        # Get any keys to save<br/>        saved = {}<br/>    <br/>        redirect_query_params = self._get_redirect_query_params(response)<br/>    <br/>        saved.update(self._save_value("body", body))<br/>        saved.update(self._save_value("headers", response.headers))<br/>        saved.update(self._save_value("redirect_query_params", redirect_query_params))<br/>    <br/>        for cookie in self.expected.get("cookies", []):<br/>            if cookie not in response.cookies:<br/>                self._adderr("No cookie named '%s' in response", cookie)<br/>    <br/>        try:<br/>            wrapped = get_wrapped_response_function(self.expected["save"]["$ext"])<br/>        except KeyError:<br/>            logger.debug("No save function for this stage")<br/>        else:<br/>            try:<br/>                to_save = wrapped(response)<br/>            except Exception as e: #pylint: disable=broad-except<br/>                self._adderr("Error calling save function '%s':\n%s",<br/>                    wrapped.func,<br/>                    indent_err_text(traceback.format_exc()),<br/>                    e=e)<br/>            else:<br/>                if isinstance(to_save, dict):<br/>                    saved.update(to_save)<br/>                elif to_save is not None:<br/>                    self._adderr("Unexpected return value '%s' from $ext save function")<br/>    <br/>        self._validate_block("body", body)<br/>        self._validate_block("headers", response.headers)<br/>        self._validate_block("redirect_query_params", redirect_query_params)<br/>    <br/>        if self.errors:<br/>&gt;           raise TestFailError("Test '{:s}' failed:\n{:s}".format(self.name, self._str_errors()), failures=self.errors)<br/><span class="error">E           TestFailError: Test 'Both CurrentBlockHeight and HeaderHash are changing frequently.' failed:</span><br/><span class="error">E           - Value mismatch in body: Key mismatch: (expected["result"]["node"] = 'seele node1', actual["result"]["node"] = 'seele node2')</span><br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/tavern/_plugins/rest/response.py:207: TestFailError<br/>------------------------------ Captured log call -------------------------------<br/>base.py                     37 ERROR    Value mismatch in body: Key mismatch: (expected["result"]["node"] = 'seele node1', actual["result"]["node"] = 'seele node2')</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">http/test_nodeInfo.tavern.yaml::This method returns the node information of the node</td>
          <td class="col-duration">0.10</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;CallInfo when='call' exception: Test 'Both CurrentBlockHeight and HeaderHash ...d["result"]["node"] = 'seele node1', actual["result"]["node"] = 'seele node2')&gt;<br/>func = &lt;function &lt;lambda&gt; at 0x10c2f9410&gt;, when = 'call', treat_keyboard_interrupt_as_exception = False<br/><br/>    def __init__(self, func, when, treat_keyboard_interrupt_as_exception=False):<br/>        #: context of invocation: one of "setup", "call",<br/>        #: "teardown", "memocollect"<br/>        self.when = when<br/>        self.start = time()<br/>        try:<br/>&gt;           self.result = func()<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/_pytest/runner.py:211: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>&gt;       lambda: ihook(item=item, **kwds),<br/>        when=when,<br/>        treat_keyboard_interrupt_as_exception=item.config.getvalue("usepdb"),<br/>    )<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/_pytest/runner.py:193: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;_HookCaller 'pytest_runtest_call'&gt;, args = (), kwargs = {'item': &lt;YamlItem 'This method returns the node information of the node'&gt;}, notincall = set([])<br/><br/>    def __call__(self, *args, **kwargs):<br/>        if args:<br/>            raise TypeError("hook calling supports only keyword arguments")<br/>        assert not self.is_historic()<br/>        if self.spec and self.spec.argnames:<br/>            notincall = (<br/>                set(self.spec.argnames) - set(["__multicall__"]) - set(kwargs.keys())<br/>            )<br/>            if notincall:<br/>                warnings.warn(<br/>                    "Argument(s) {} which are declared in the hookspec "<br/>                    "can not be found in this hook call".format(tuple(notincall)),<br/>                    stacklevel=2,<br/>                )<br/>&gt;       return self._hookexec(self, self.get_hookimpls(), kwargs)<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/pluggy/hooks.py:284: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;_pytest.config.PytestPluginManager object at 0x10b920590&gt;, hook = &lt;_HookCaller 'pytest_runtest_call'&gt;<br/>methods = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/Users/frank/venv/testEnv/lib/python2.7/site-pa...t 0x10bee0c10&gt;&gt;, &lt;HookImpl plugin_name='logging-plugin', plugin=&lt;_pytest.logging.LoggingPlugin object at 0x10bf06f50&gt;&gt;]<br/>kwargs = {'item': &lt;YamlItem 'This method returns the node information of the node'&gt;}<br/><br/>    def _hookexec(self, hook, methods, kwargs):<br/>        # called from all hookcaller instances.<br/>        # enable_tracing will set its own wrapping function at self._inner_hookexec<br/>&gt;       return self._inner_hookexec(hook, methods, kwargs)<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/pluggy/manager.py:67: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>hook = &lt;_HookCaller 'pytest_runtest_call'&gt;<br/>methods = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/Users/frank/venv/testEnv/lib/python2.7/site-pa...t 0x10bee0c10&gt;&gt;, &lt;HookImpl plugin_name='logging-plugin', plugin=&lt;_pytest.logging.LoggingPlugin object at 0x10bf06f50&gt;&gt;]<br/>kwargs = {'item': &lt;YamlItem 'This method returns the node information of the node'&gt;}<br/><br/>    self._inner_hookexec = lambda hook, methods, kwargs: hook.multicall(<br/>        methods,<br/>        kwargs,<br/>&gt;       firstresult=hook.spec.opts.get("firstresult") if hook.spec else False,<br/>    )<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/pluggy/manager.py:61: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>hook_impls = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/Users/frank/venv/testEnv/lib/python2.7/site-pa...t 0x10bee0c10&gt;&gt;, &lt;HookImpl plugin_name='logging-plugin', plugin=&lt;_pytest.logging.LoggingPlugin object at 0x10bf06f50&gt;&gt;]<br/>caller_kwargs = {'item': &lt;YamlItem 'This method returns the node information of the node'&gt;}, firstresult = False<br/><br/>    def _multicall(hook_impls, caller_kwargs, firstresult=False):<br/>        """Execute a call into multiple python functions/methods and return the<br/>        result(s).<br/>    <br/>        ``caller_kwargs`` comes from _HookCaller.__call__().<br/>        """<br/>        __tracebackhide__ = True<br/>        results = []<br/>        excinfo = None<br/>        try:  # run impl and wrapper setup functions in a loop<br/>            teardowns = []<br/>            try:<br/>                for hook_impl in reversed(hook_impls):<br/>                    try:<br/>                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]<br/>                    except KeyError:<br/>                        for argname in hook_impl.argnames:<br/>                            if argname not in caller_kwargs:<br/>                                raise HookCallError(<br/>                                    "hook call must provide argument %r" % (argname,)<br/>                                )<br/>    <br/>                    if hook_impl.hookwrapper:<br/>                        try:<br/>                            gen = hook_impl.function(*args)<br/>                            next(gen)  # first yield<br/>                            teardowns.append(gen)<br/>                        except StopIteration:<br/>                            _raise_wrapfail(gen, "did not yield")<br/>                    else:<br/>                        res = hook_impl.function(*args)<br/>                        if res is not None:<br/>                            results.append(res)<br/>                            if firstresult:  # halt further impl calls<br/>                                break<br/>            except BaseException:<br/>                excinfo = sys.exc_info()<br/>        finally:<br/>            if firstresult:  # first result hooks return a single value<br/>                outcome = _Result(results[0] if results else None, excinfo)<br/>            else:<br/>                outcome = _Result(results, excinfo)<br/>    <br/>            # run all wrapper post-yield blocks<br/>            for gen in reversed(teardowns):<br/>                try:<br/>                    gen.send(outcome)<br/>                    _raise_wrapfail(gen, "has second yield")<br/>                except StopIteration:<br/>                    pass<br/>    <br/>&gt;           return outcome.get_result()<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/pluggy/callers.py:208: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;pluggy.callers._Result object at 0x10d05a5d0&gt;<br/><br/>    def get_result(self):<br/>        """Get the result(s) for this hook call.<br/>    <br/>        If the hook was marked as a ``firstresult`` only a single value<br/>        will be returned otherwise a list of results.<br/>        """<br/>        __tracebackhide__ = True<br/>        if self._excinfo is None:<br/>            return self._result<br/>        else:<br/>            ex = self._excinfo<br/>            if _py3:<br/>                raise ex[1].with_traceback(ex[2])<br/>&gt;           _reraise(*ex)  # noqa<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/pluggy/callers.py:81: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>hook_impls = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/Users/frank/venv/testEnv/lib/python2.7/site-pa...t 0x10bee0c10&gt;&gt;, &lt;HookImpl plugin_name='logging-plugin', plugin=&lt;_pytest.logging.LoggingPlugin object at 0x10bf06f50&gt;&gt;]<br/>caller_kwargs = {'item': &lt;YamlItem 'This method returns the node information of the node'&gt;}, firstresult = False<br/><br/>    def _multicall(hook_impls, caller_kwargs, firstresult=False):<br/>        """Execute a call into multiple python functions/methods and return the<br/>        result(s).<br/>    <br/>        ``caller_kwargs`` comes from _HookCaller.__call__().<br/>        """<br/>        __tracebackhide__ = True<br/>        results = []<br/>        excinfo = None<br/>        try:  # run impl and wrapper setup functions in a loop<br/>            teardowns = []<br/>            try:<br/>                for hook_impl in reversed(hook_impls):<br/>                    try:<br/>                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]<br/>                    except KeyError:<br/>                        for argname in hook_impl.argnames:<br/>                            if argname not in caller_kwargs:<br/>                                raise HookCallError(<br/>                                    "hook call must provide argument %r" % (argname,)<br/>                                )<br/>    <br/>                    if hook_impl.hookwrapper:<br/>                        try:<br/>                            gen = hook_impl.function(*args)<br/>                            next(gen)  # first yield<br/>                            teardowns.append(gen)<br/>                        except StopIteration:<br/>                            _raise_wrapfail(gen, "did not yield")<br/>                    else:<br/>&gt;                       res = hook_impl.function(*args)<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/pluggy/callers.py:187: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>item = &lt;YamlItem 'This method returns the node information of the node'&gt;<br/><br/>    def pytest_runtest_call(item):<br/>        _update_current_test_var(item, "call")<br/>        sys.last_type, sys.last_value, sys.last_traceback = (None, None, None)<br/>        try:<br/>&gt;           item.runtest()<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/_pytest/runner.py:121: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;YamlItem 'This method returns the node information of the node'&gt;<br/><br/>    def runtest(self):<br/>        self.global_cfg = self._parse_arguments()<br/>    <br/>        self.global_cfg.setdefault("variables", {})<br/>    <br/>        load_plugins(self.global_cfg)<br/>    <br/>        # INTERNAL<br/>        # NOTE - now that we can 'mark' tests, we could use pytest.mark.xfail<br/>        # instead. This doesn't differentiate between an error in verification<br/>        # and an error when running the test though.<br/>        xfail = self.spec.get("_xfail", False)<br/>    <br/>        try:<br/>            verify_tests(self.spec)<br/>    <br/>            fixture_values = self._load_fixture_values()<br/>            self.global_cfg["variables"].update(fixture_values)<br/>    <br/>&gt;           run_test(self.path, self.spec, self.global_cfg)<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/tavern/testutils/pytesthook.py:431: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>in_file = local('/Users/frank/code/github/api-test/http/test_nodeInfo.tavern.yaml')<br/>test_spec = {'stages': [{'request': {'url': '{service.proto:s}://{service.host:s}:{service...server'}], 'test_name': 'This method returns the node information of the node'}<br/>global_cfg = {'backends': {'http': 'requests', 'mqtt': 'paho-mqtt'}, 'strict': [], 'variables': {'node': {'Coinbase': '0xe2bbc9fadb...t-type': 'application/json'}, 'json..._TEXT_ENCODING': '0x1F7:0x0:0x0', 'PWD': '/Users/frank/code/github/api-test'}}&gt;}}<br/><br/>    def run_test(in_file, test_spec, global_cfg):<br/>        """Run a single tavern test<br/>    <br/>        Note that each tavern test can consist of multiple requests (log in,<br/>        create, update, delete, etc).<br/>    <br/>        The global configuration is copied and used as an initial configuration for<br/>        this test. Any values which are saved from any tests are saved into this<br/>        test block and can be used for formatting in later stages in the test.<br/>    <br/>        Args:<br/>            in_file (str): filename containing this test<br/>            test_spec (dict): The specification for this test<br/>            global_cfg (dict): Any global configuration for this test<br/>    <br/>        No Longer Raises:<br/>            TavernException: If any of the tests failed<br/>        """<br/>    <br/>        # pylint: disable=too-many-locals<br/>    <br/>        # Initialise test config for this test with the global configuration before<br/>        # starting<br/>        test_block_config = dict(global_cfg)<br/>    <br/>        if "variables" not in test_block_config:<br/>            test_block_config["variables"] = {}<br/>    <br/>        tavern_box = Box({<br/>            "env_vars": dict(os.environ),<br/>        })<br/>    <br/>        if not test_spec:<br/>            logger.warning("Empty test block in %s", in_file)<br/>            return<br/>    <br/>        available_stages = {}<br/>        if test_spec.get("includes"):<br/>            for included in test_spec["includes"]:<br/>                if "variables" in included:<br/>                    formatted_include = format_keys(included["variables"], {"tavern": tavern_box})<br/>                    test_block_config["variables"].update(formatted_include)<br/>    <br/>                if "stages" in included:<br/>                    for stage in included["stages"]:<br/>                        if stage["id"] in available_stages:<br/>                            raise exceptions.DuplicateStageDefinitionError(<br/>                                "Stage with specified id already defined: {}".format(stage["id"]))<br/>                        available_stages[stage["id"]] = stage<br/>    <br/>        test_block_config["variables"]["tavern"] = tavern_box<br/>    <br/>        test_block_name = test_spec["test_name"]<br/>    <br/>        # Strict on body by default<br/>        default_strictness = test_block_config["strict"]<br/>    <br/>        logger.info("Running test : %s", test_block_name)<br/>    <br/>        with ExitStack() as stack:<br/>            test_spec["stages"] = _resolve_test_stages(test_spec, available_stages)<br/>            sessions = get_extra_sessions(test_spec, test_block_config)<br/>    <br/>            for name, session in sessions.items():<br/>                logger.debug("Entering context for %s", name)<br/>                stack.enter_context(session)<br/>    <br/>            # Run tests in a path in order<br/>            for stage in test_spec["stages"]:<br/>                if stage.get('skip'):<br/>                    continue<br/>    <br/>                test_block_config["strict"] = default_strictness<br/>    <br/>                # Can be overridden per stage<br/>                # NOTE<br/>                # this is hardcoded to check for the 'response' block. In the far<br/>                # future there might not be a response block, but at the moment it<br/>                # is the hardcoded value for any HTTP request.<br/>                if stage.get("response", {}):<br/>                    if stage.get("response").get("strict", None) is not None:<br/>                        stage_strictness = stage.get("response").get("strict", None)<br/>                    elif test_spec.get("strict", None) is not None:<br/>                        stage_strictness = test_spec.get("strict", None)<br/>                    else:<br/>                        stage_strictness = default_strictness<br/>    <br/>                    logger.debug("Strict key checking for this stage is '%s'", stage_strictness)<br/>    <br/>                    test_block_config["strict"] = stage_strictness<br/>                elif default_strictness:<br/>                    logger.debug("Default strictness '%s' ignored for this stage", default_strictness)<br/>    <br/>                run_stage_ = run_stage<br/>                if stage.get('max_retries'):<br/>                    run_stage_ = retry(stage)(run_stage_)<br/>    <br/>                try:<br/>&gt;                   run_stage_(sessions, stage, tavern_box, test_block_config)<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/tavern/core.py:145: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>sessions = {'requests': &lt;requests.sessions.Session object at 0x10c16c450&gt;}<br/>stage = {'request': {'url': '{service.proto:s}://{service.host:s}:{service.port:d}', '...o', 'client': '1.0', 'os': 'linux', 'netVersion': '1.0'}}, 'status_code': 200}}<br/>tavern_box = &lt;Box: {'request_vars': {'headers': {'content-type': 'application/json'}, 'json..._TEXT_ENCODING': '0x1F7:0x0:0x0', 'PWD': '/Users/frank/code/github/api-test'}}&gt;<br/>test_block_config = {'backends': {'http': 'requests', 'mqtt': 'paho-mqtt'}, 'strict': [], 'variables': {'node': {'Coinbase': '0xe2bbc9fadb...t-type': 'application/json'}, 'json..._TEXT_ENCODING': '0x1F7:0x0:0x0', 'PWD': '/Users/frank/code/github/api-test'}}&gt;}}<br/><br/>    def run_stage(sessions, stage, tavern_box, test_block_config):<br/>        """Run one stage from the test<br/>    <br/>        Args:<br/>            sessions (list): List of relevant 'session' objects used for this test<br/>            stage (dict): specification of stage to be run<br/>            tavern_box (box.Box): Box object containing format variables to be used<br/>                in test<br/>            test_block_config (dict): available variables for test<br/>        """<br/>        name = stage["name"]<br/>    <br/>        r = get_request_type(stage, test_block_config, sessions)<br/>    <br/>        tavern_box.update(request_vars=r.request_vars)<br/>    <br/>        expected = get_expected(stage, test_block_config, sessions)<br/>    <br/>        delay(stage, "before")<br/>    <br/>        logger.info("Running stage : %s", name)<br/>        response = r.run()<br/>    <br/>        verifiers = get_verifiers(stage, test_block_config, sessions, expected)<br/>        for v in verifiers:<br/>&gt;           saved = v.verify(response)<br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/tavern/core.py:180: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;tavern._plugins.rest.response.RestResponse object at 0x10d17f610&gt;, response = &lt;Response [200]&gt;<br/><br/>    def verify(self, response):<br/>        """Verify response against expected values and returns any values that<br/>        we wanted to save for use in future requests<br/>    <br/>        There are various ways to 'validate' a block - a specific function, just<br/>        matching values, validating a schema, etc...<br/>    <br/>        Args:<br/>            response (requests.Response): response object<br/>    <br/>        Returns:<br/>            dict: Any saved values<br/>    <br/>        Raises:<br/>            TestFailError: Something went wrong with validating the response<br/>        """<br/>        # pylint: disable=too-many-statements<br/>    <br/>        self._verbose_log_response(response)<br/>    <br/>        self.response = response<br/>        self.status_code = response.status_code<br/>    <br/>        try:<br/>            body = response.json()<br/>        except ValueError:<br/>            body = None<br/>    <br/>        self._check_status_code(response.status_code, body)<br/>    <br/>        if self.validate_function:<br/>            try:<br/>                self.validate_function(response)<br/>            except Exception as e: #pylint: disable=broad-except<br/>                self._adderr("Error calling validate function '%s':\n%s",<br/>                    self.validate_function.func,<br/>                    indent_err_text(traceback.format_exc()),<br/>                    e=e)<br/>    <br/>        # Get any keys to save<br/>        saved = {}<br/>    <br/>        redirect_query_params = self._get_redirect_query_params(response)<br/>    <br/>        saved.update(self._save_value("body", body))<br/>        saved.update(self._save_value("headers", response.headers))<br/>        saved.update(self._save_value("redirect_query_params", redirect_query_params))<br/>    <br/>        for cookie in self.expected.get("cookies", []):<br/>            if cookie not in response.cookies:<br/>                self._adderr("No cookie named '%s' in response", cookie)<br/>    <br/>        try:<br/>            wrapped = get_wrapped_response_function(self.expected["save"]["$ext"])<br/>        except KeyError:<br/>            logger.debug("No save function for this stage")<br/>        else:<br/>            try:<br/>                to_save = wrapped(response)<br/>            except Exception as e: #pylint: disable=broad-except<br/>                self._adderr("Error calling save function '%s':\n%s",<br/>                    wrapped.func,<br/>                    indent_err_text(traceback.format_exc()),<br/>                    e=e)<br/>            else:<br/>                if isinstance(to_save, dict):<br/>                    saved.update(to_save)<br/>                elif to_save is not None:<br/>                    self._adderr("Unexpected return value '%s' from $ext save function")<br/>    <br/>        self._validate_block("body", body)<br/>        self._validate_block("headers", response.headers)<br/>        self._validate_block("redirect_query_params", redirect_query_params)<br/>    <br/>        if self.errors:<br/>&gt;           raise TestFailError("Test '{:s}' failed:\n{:s}".format(self.name, self._str_errors()), failures=self.errors)<br/><span class="error">E           TestFailError: Test 'Both CurrentBlockHeight and HeaderHash are changing frequently.' failed:</span><br/><span class="error">E           - Value mismatch in body: Key mismatch: (expected["result"]["node"] = 'seele node1', actual["result"]["node"] = 'seele node2')</span><br/><br/>../../../venv/testEnv/lib/python2.7/site-packages/tavern/_plugins/rest/response.py:207: TestFailError<br/>------------------------------ Captured log call -------------------------------<br/>base.py                     37 ERROR    Value mismatch in body: Key mismatch: (expected["result"]["node"] = 'seele node1', actual["result"]["node"] = 'seele node2')</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">http/test_32000.tavern.yaml::gas price is nil</td>
          <td class="col-duration">0.26</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="empty log">No log output captured.</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">http/test_32602.tavern.yaml::missing value for required argument 1</td>
          <td class="col-duration">0.10</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">------------------------------ Captured log call -------------------------------<br/>dict_util.py               292 WARNING  Structure of returned data was different than expected  - Extra keys in response: set([u'id']) (expected = '{'jsonrpc': '2.0', 'error': {'message': 'missing value for required argument 1', 'code': -32602}}', actual = '{u'jsonrpc': u'2.0', u'id': 1, u'error': {u'message': u'missing value for required argument 1', u'code': -32602}}')
Traceback (most recent call last):
  File "/Users/frank/venv/testEnv/lib/python2.7/site-packages/tavern/util/dict_util.py", line 259, in check_keys_match_recursive
    assert actual_val == expected_val
AssertionError: assert {'error': {'c...onrpc': '2.0'} == {'error': {'co...onrpc': '2.0'}
  Omitting 2 identical items, use -vv to show
  Left contains more items:
  {u'id': 1}
  Use -v to get the full diff</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">http/test_3260X.tavern.yaml::Invalid method name</td>
          <td class="col-duration">0.09</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="empty log">No log output captured.</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">http/test_3270X.tavern.yaml::Invalid method name</td>
          <td class="col-duration">0.09</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="empty log">No log output captured.</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">http/test_getAccountNonce.tavern.yaml::This method is used to obtain the account nonce.</td>
          <td class="col-duration">0.10</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="empty log">No log output captured.</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">http/test_getBalance.tavern.yaml::This method returns the account balance.</td>
          <td class="col-duration">0.10</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="empty log">No log output captured.</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">http/test_getBlockByHash.tavern.yaml::This method is used to obtain the block content based on block hash.</td>
          <td class="col-duration">0.11</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="empty log">No log output captured.</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">http/test_getBlockHeight.tavern.yaml::This method is used to obtain the height of the blockchain.</td>
          <td class="col-duration">0.09</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">------------------------------ Captured log call -------------------------------<br/>dict_util.py               292 WARNING  Structure of returned data was different than expected  - Extra keys in response: set([u'result']) (expected = '{'jsonrpc': '2.0', 'id': 1}', actual = '{u'jsonrpc': u'2.0', u'id': 1, u'result': 49423}')
Traceback (most recent call last):
  File "/Users/frank/venv/testEnv/lib/python2.7/site-packages/tavern/util/dict_util.py", line 259, in check_keys_match_recursive
    assert actual_val == expected_val
AssertionError: assert {'id': 1, 'js...esult': 49423} == {'id': 1, 'jsonrpc': '2.0'}
  Omitting 2 identical items, use -vv to show
  Left contains more items:
  {u'result': 49423}
  Use -v to get the full diff</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">http/test_nodeStats.tavern.yaml::This method returns the information of the node</td>
          <td class="col-duration">0.11</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="empty log">No log output captured.</div></td></tr></tbody></table></body></html>